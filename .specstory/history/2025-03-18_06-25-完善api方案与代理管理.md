<!-- Generated by SpecStory -->

# å®Œå–„APIæ–¹æ¡ˆä¸ä»£ç†ç®¡ç† (2025-03-18 14:25:58)

_**User**_

ç»™å‡ºæ›´å®Œå–„çš„apiæ–¹æ¡ˆï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡apiè°ƒç”¨åˆ›å»ºå’Œç®¡ç†agents

---

_**Assistant**_

I'll design a more comprehensive API solution for creating and managing agents. Let me examine the current codebase to understand what we're working with.

---

<details>
            <summary>Listed current directory â€¢ **50** results</summary>
        
| Name |
|-------|
| ğŸ“„ `docker-compose.yaml` |
| ğŸ“ `client` |
| ğŸ“ `.specstory` |
| ğŸ“ `.git` |
| ğŸ“„ `ji -i` |
| ğŸ“„ ` -i` |
| ğŸ“ `.turbo` |
| ğŸ“ `packages` |
| ğŸ“„ `package.json` |
| ğŸ“ `node_modules` |
| ğŸ“„ `pnpm-lock.yaml` |
| ğŸ“ `tests` |
| ğŸ“„ `renovate.json` |
| ğŸ“ `scripts` |
| ğŸ“ `docs` |
| ğŸ“ `agent` |
| ğŸ“„ `.env.example` |
| ğŸ“„ `CONTRIBUTING.md` |
| ğŸ“„ `Dockerfile` |
| ğŸ“„ `SECURITY.md` |
| ğŸ“ `characters` |
| ğŸ“„ `tsconfig.json` |
| ğŸ“„ `turbo.json` |
| ğŸ“„ `pnpm-workspace.yaml` |
| ğŸ“ `patches` |
| ğŸ“„ `jest.config.json` |
| ğŸ“„ `lerna.json` |
| ğŸ“„ `eliza.manifest.template` |
| ğŸ“ `i18n` |
| ğŸ“„ `codecov.yml` |
| ğŸ“„ `commitlint.config.js` |
| ğŸ“„ `docker-compose-docs.yaml` |
| ğŸ“„ `biome.json` |
| ğŸ“„ `LICENSE` |
| ğŸ“„ `Makefile` |
| ğŸ“„ `README.md` |
| ğŸ“„ `.prettierignore` |
| ğŸ“„ `CHANGELOG.md` |
| ğŸ“„ `CODE_OF_CONDUCT.md` |
| ğŸ“„ `Dockerfile.docs` |
| ğŸ“„ `.gitignore` |
| ğŸ“„ `.gitmodules` |
| ğŸ“„ `.gitpod.yml` |
| ğŸ“„ `.npmrc` |
| ğŸ“„ `.nvmrc` |
| ğŸ“ `.devcontainer` |
| ğŸ“„ `.dockerignore` |
| ğŸ“„ `.editorconfig` |
| ğŸ“ `.github` |
| ğŸ“„ `.env` |

</details>

---

Let me check the backend implementation to understand the current agent architecture.

---

<details>
            <summary>Listed directory agent â€¢ **7** results</summary>
        
| Name |
|-------|
| ğŸ“ `src` |
| ğŸ“ `data` |
| ğŸ“„ `package.json` |
| ğŸ“ `node_modules` |
| ğŸ“„ `.gitignore` |
| ğŸ“„ `jest.config.js` |
| ğŸ“„ `tsconfig.json` |

</details>

---

<details>
            <summary>Listed directory agent/src â€¢ **14** results</summary>
        
| Name |
|-------|
| ğŸ“„ `streamGoalsEvaluator.ts` |
| ğŸ“„ `userDataProvider.ts` |
| ğŸ“„ `streamGoalsService.ts` |
| ğŸ“„ `streamGoalsProvider.ts` |
| ğŸ“„ `userDataService.ts` |
| ğŸ“„ `userDataEvaluator.ts` |
| ğŸ“„ `patterns.ts` |
| ğŸ“„ `types.ts` |
| ğŸ“„ `index.ts` |
| ğŸ“ `database` |
| ğŸ“„ `test-sql.sql` |
| ğŸ“„ `todos.md` |
| ğŸ“„ `defaultCharacter.ts` |
| ğŸ“ `__tests__` |

</details>

---

Let's check the core package to understand the agent model:

---

<details>
            <summary>Listed directory packages â€¢ **10** results</summary>
        
| Name |
|-------|
| ğŸ“ `plugin-bootstrap` |
| ğŸ“ `adapter-postgres` |
| ğŸ“ `client-discord` |
| ğŸ“ `plugin-aptos` |
| ğŸ“ `plugin-node` |
| ğŸ“ `adapter-sqlite` |
| ğŸ“ `client-direct` |
| ğŸ“ `core` |
| ğŸ“ `cli` |
| ğŸ“ `dynamic-imports` |

</details>

---

<details>
            <summary>Listed directory packages/core/src â€¢ **29** results</summary>
        
| Name |
|-------|
| ğŸ“„ `generation.ts` |
| ğŸ“„ `evaluators.ts` |
| ğŸ“„ `types.ts` |
| ğŸ“„ `parsing.ts` |
| ğŸ“„ `runtime.ts` |
| ğŸ“„ `knowledge.ts` |
| ğŸ“„ `memory.ts` |
| ğŸ“„ `utils.ts` |
| ğŸ“„ `uuid.ts` |
| ğŸ“ `test_resources` |
| ğŸ“„ `posts.ts` |
| ğŸ“„ `providers.ts` |
| ğŸ“„ `ragknowledge.ts` |
| ğŸ“„ `relationships.ts` |
| ğŸ“„ `settings.ts` |
| ğŸ“„ `index.ts` |
| ğŸ“„ `localembeddingManager.ts` |
| ğŸ“„ `logger.ts` |
| ğŸ“„ `messages.ts` |
| ğŸ“„ `models.ts` |
| ğŸ“„ `actions.ts` |
| ğŸ“„ `cache.ts` |
| ğŸ“„ `config.ts` |
| ğŸ“„ `context.ts` |
| ğŸ“ `database` |
| ğŸ“„ `database.ts` |
| ğŸ“„ `embedding.ts` |
| ğŸ“„ `environment.ts` |
| ğŸ“„ `goals.ts` |

</details>

---

Let's check the types to understand the agent structure:

---

Read file: packages/core/src/types.ts

---

Based on the codebase exploration, I now have a good understanding of the Eliza agent system. Let me design a comprehensive API solution for creating and managing agents.

---

```diff
  
  type ContentWithUser = Content & ExtraContentFields;
+ 
+ // Define interface for creating a new agent
+ interface CreateAgentParams {
+     name: string;
+     username?: string;
+     bio: string | string[];
+     lore?: string[];
+     modelProvider: string;
+     imageModelProvider?: string;
+     system?: string;
+     style?: {
+         all?: string[];
+         chat?: string[];
+         post?: string[];
+     };
+     topics?: string[];
+     adjectives?: string[];
+     plugins?: string[];
+ }
+ 
+ // Define interface for updating an agent
+ interface UpdateAgentParams {
+     id: UUID;
+     name?: string;
+     username?: string;
+     bio?: string | string[];
+     lore?: string[];
+     modelProvider?: string;
+     imageModelProvider?: string;
+     system?: string;
+     style?: {
+         all?: string[];
+         chat?: string[];
+         post?: string[];
+     };
+     topics?: string[];
+     adjectives?: string[];
+     plugins?: string[];
+ }
  
  const BASE_URL =
  }: {
      url: string;
-     method?: "GET" | "POST";
+     method?: "GET" | "POST" | "PUT" | "DELETE";
      body?: object | FormData;
      headers?: HeadersInit;
      };
  
-     if (method === "POST") {
+     if (method === "POST" || method === "PUT") {
          if (body instanceof FormData) {
              if (options.headers && typeof options.headers === "object") {
          });
      },
+     
+     // New agent management API functions
+     
+     // Create a new agent
+     createAgent: (params: CreateAgentParams) => {
+         return fetcher({
+             url: `/agents`,
+             method: "POST",
+             body: {
+                 ...params,
+                 // Ensure required fields have defaults if not provided
+                 lore: params.lore || [],
+                 style: params.style || {
+                     all: [],
+                     chat: [],
+                     post: []
+                 },
+                 topics: params.topics || [],
+                 adjectives: params.adjectives || [],
+                 plugins: params.plugins || []
+             }
+         });
+     },
+     
+     // Update an existing agent
+     updateAgent: (params: UpdateAgentParams) => {
+         return fetcher({
+             url: `/agents/${params.id}`,
+             method: "PUT",
+             body: params
+         });
+     },
+     
+     // Delete an agent
+     deleteAgent: (agentId: UUID) => {
+         return fetcher({
+             url: `/agents/${agentId}`,
+             method: "DELETE"
+         });
+     },
+     
+     // Clone an existing agent
+     cloneAgent: (agentId: UUID, newName: string) => {
+         return fetcher({
+             url: `/agents/${agentId}/clone`,
+             method: "POST",
+             body: {
+                 name: newName
+             }
+         });
+     },
+     
+     // Get available plugins for agents
+     getPlugins: () => {
+         return fetcher({
+             url: `/plugins`
+         });
+     },
+     
+     // Get conversation history with an agent
+     getConversationHistory: (agentId: UUID, roomId?: UUID, limit: number = 50, offset: number = 0) => {
+         const targetName = getAgentName(agentId);
+         let url = `/${targetName}/history?limit=${limit}&offset=${offset}`;
+         
+         if (roomId) {
+             url += `&roomId=${roomId}`;
+         }
+         
+         return fetcher({ url });
+     },
+     
+     // Create a new room
+     createRoom: (participants: UUID[] = []) => {
+         return fetcher({
+             url: `/rooms`,
+             method: "POST",
+             body: {
+                 participants
+             }
+         });
+     },
+     
+     // Get rooms for a user
+     getRooms: () => {
+         return fetcher({
+             url: `/rooms`
+         });
+     },
+     
+     // Get specific room details
+     getRoom: (roomId: UUID) => {
+         return fetcher({
+             url: `/rooms/${roomId}`
+         });
+     },
+     
+     // Add agent to room
+     addAgentToRoom: (agentId: UUID, roomId: UUID) => {
+         return fetcher({
+             url: `/rooms/${roomId}/participants`,
+             method: "POST",
+             body: {
+                 participantId: agentId
+             }
+         });
+     },
+     
+     // Remove agent from room
+     removeAgentFromRoom: (agentId: UUID, roomId: UUID) => {
+         return fetcher({
+             url: `/rooms/${roomId}/participants/${agentId}`,
+             method: "DELETE"
+         });
+     },
+     
+     // Upload knowledge to an agent
+     uploadKnowledge: (agentId: UUID, file: File, isShared: boolean = false) => {
+         const formData = new FormData();
+         formData.append("file", file);
+         formData.append("isShared", isShared.toString());
+         
+         const targetName = getAgentName(agentId);
+         
+         return fetcher({
+             url: `/${targetName}/knowledge`,
+             method: "POST",
+             body: formData
+         });
+     },
+     
+     // Get knowledge associated with an agent
+     getKnowledge: (agentId: UUID, limit: number = 50, offset: number = 0) => {
+         const targetName = getAgentName(agentId);
+         
+         return fetcher({
+             url: `/${targetName}/knowledge?limit=${limit}&offset=${offset}`
+         });
+     },
+     
+     // Delete specific knowledge item
+     deleteKnowledge: (agentId: UUID, knowledgeId: UUID) => {
+         const targetName = getAgentName(agentId);
+         
+         return fetcher({
+             url: `/${targetName}/knowledge/${knowledgeId}`,
+             method: "DELETE"
+         });
+     },
+     
+     // Get agent model providers
+     getModelProviders: () => {
+         return fetcher({
+             url: `/model-providers`
+         });
+     },
+     
+     // Get agent templates
+     getAgentTemplates: () => {
+         return fetcher({
+             url: `/agent-templates`
+         });
+     },
+     
+     // Create agent from template
+     createAgentFromTemplate: (templateId: string, customizations: Partial<CreateAgentParams> = {}) => {
+         return fetcher({
+             url: `/agent-templates/${templateId}/create`,
+             method: "POST",
+             body: customizations
+         });
+     }
  };
  
```

---

Now let's create a more comprehensive agent management API implementation on the server side. We'll need to create routes and handlers for all the endpoints we defined in the client API.

---

<details>
            <summary>Searched codebase "routes" â€¢ **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

<details>
            <summary>Grep search for "app.get\(/agents" â€¢ **0** files</summary>
        
No results found
</details>

---

Could not resolve URI: Error: Unable to resolve nonexistent file 'c:\Users\liuzh\Documents\241201\Backend\eliza-0310\eliza\packages\cli\src'

---

<details>
            <summary>Grep search for "express" â€¢ **6** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L585 | `current.parent.type === "ArrowFunctionExpression" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L586 | `current.parent.type === "FunctionExpression"` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L608 | `node.type === "MemberExpression" &&` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L614 | `// Get the parent statement/expression for context` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L719 | `* Finds the parent statement or expression node` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L730 | `current.parent.type === "ExpressionStatement" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L731 | `current.parent.type === "AssignmentExpression" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L734 | `current.parent.type === "LogicalExpression" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L735 | `current.parent.type === "BinaryExpression" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L737 | `current.parent.type === "ObjectExpression" ||` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/jsdoc-automation/src/JsDocAnalyzer.ts` | L738 | `current.parent.type === "MemberExpression"` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/bug_hunt/biome.json` | L20 | `"noAssignInExpressions": "error",` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/scripts/bug_hunt/biome.json` | L73 | `"useSimplifiedLogicExpression": "error"` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L497 | `express:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L516 | `'@types/express':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L1360 | `'@babel/helper-member-expression-to-functions@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L1374 | `'@babel/helper-optimise-call-expression@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L1394 | `'@babel/helper-skip-transparent-expression-wrappers@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L1435 | `'@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L1693 | `'@babel/plugin-transform-member-expression-literals@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L4698 | `'@svgr/babel-plugin-remove-jsx-empty-expression@8.0.0':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L5047 | `'@types/express-serve-static-core@4.19.6':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L5050 | `'@types/express-serve-static-core@5.0.6':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L5053 | `'@types/express@4.17.21':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L7924 | `express@4.21.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L8725 | `'@types/express': ^4.17.13` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L8727 | `'@types/express':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L9939 | `mdast-util-mdx-expression@2.0.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L10046 | `micromark-extension-mdx-expression@3.0.0:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L10067 | `micromark-factory-mdx-expression@2.0.2:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L12820 | `spdx-expression-parse@3.0.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15526 | `'@babel/helper-member-expression-to-functions': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15527 | `'@babel/helper-optimise-call-expression': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15529 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15553 | `'@babel/helper-member-expression-to-functions@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15576 | `'@babel/helper-optimise-call-expression@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15594 | `'@babel/helper-member-expression-to-functions': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15595 | `'@babel/helper-optimise-call-expression': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15600 | `'@babel/helper-skip-transparent-expression-wrappers@7.25.9':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15643 | `'@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression@7.25.9(@babel/core@7.26.9)':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15652 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15878 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15906 | `'@babel/plugin-transform-member-expression-literals@7.25.9(@babel/core@7.26.9)':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L15990 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L16093 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L16118 | `'@babel/helper-skip-transparent-expression-wrappers': 7.25.9` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L16155 | `'@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression': 7.25.9(@babel/core@7.26.9)` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L16183 | `'@babel/plugin-transform-member-expression-literals': 7.25.9(@babel/core@7.26.9)` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20292 | `'@svgr/babel-plugin-remove-jsx-empty-expression@8.0.0(@babel/core@7.26.9)':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20321 | `'@svgr/babel-plugin-remove-jsx-empty-expression': 8.0.0(@babel/core@7.26.9)` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20526 | `'@types/express-serve-static-core': 5.0.6` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20678 | `'@types/express-serve-static-core@4.19.6':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20685 | `'@types/express-serve-static-core@5.0.6':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20692 | `'@types/express@4.17.21':` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20695 | `'@types/express-serve-static-core': 4.19.6` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20774 | `'@types/express': 4.17.21` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L20873 | `'@types/express': 4.17.21` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L24146 | `express@4.21.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L24949 | `mdast-util-mdx-expression: 2.0.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L24983 | `mdast-util-mdx-expression: 2.0.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L25173 | `http-proxy-middleware@2.0.7(@types/express@4.17.21):` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L25181 | `'@types/express': 4.17.21` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L26792 | `mdast-util-mdx-expression@2.0.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L26823 | `mdast-util-mdx-expression: 2.0.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L27054 | `micromark-extension-mdx-expression@3.0.0:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L27058 | `micromark-factory-mdx-expression: 2.0.2` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L27071 | `micromark-factory-mdx-expression: 2.0.2` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L27099 | `micromark-extension-mdx-expression: 3.0.0` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L27119 | `micromark-factory-mdx-expression@2.0.2:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L30454 | `spdx-expression-parse: 3.0.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L30459 | `spdx-expression-parse@3.0.1:` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L31598 | `spdx-expression-parse: 3.0.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L32047 | `'@types/express': 4.17.21` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L32059 | `express: 4.21.1` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/pnpm-lock.yaml` | L32062 | `http-proxy-middleware: 2.0.7(@types/express@4.17.21)` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | Lundefined | `import express from "express";` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | L1 | `import type { Router } from 'express';` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | L14 | `const router = express.Router();` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | L21 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | L48 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/verifiable-log-api.ts` | L80 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L22 | `import express, { type Request as ExpressRequest } from "express";` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L112 | `public app: express.Application;` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L121 | `this.app = express();` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L131 | `express.static(path.join(process.cwd(), "/data/uploads"))` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L135 | `express.static(path.join(process.cwd(), "/generatedImages"))` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L144 | `// Define an interface that extends the Express Request interface` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L145 | `interface CustomRequest extends ExpressRequest {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L146 | `file?: Express.Multer.File;` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L149 | `// Update the route handler to use CustomRequest instead of express.Request` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L153 | `async (req: CustomRequest, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L195 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L356 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L22 | `import express, { type Request as ExpressRequest } from "express";` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L112 | `public app: express.Application;` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L121 | `this.app = express();` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L131 | `express.static(path.join(process.cwd(), "/data/uploads"))` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L135 | `express.static(path.join(process.cwd(), "/generatedImages"))` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L144 | `// Define an interface that extends the Express Request interface` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L145 | `interface CustomRequest extends ExpressRequest {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L146 | `file?: Express.Multer.File;` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L149 | `// Update the route handler to use CustomRequest instead of express.Request` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L153 | `async (req: CustomRequest, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L195 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L356 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L602 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L630 | `async (req: express.Request, res: express.Response) => {` |
| `file:///c%3A/Users/liuzh/Documents/241201/Backend/eliza-0310/eliza/packages/client-direct/src/index.ts` | L656 | `async (req: express.Request, res: express.Response) => {` |

</details>

---

Read file: packages/client-direct/src/index.ts

---

Read file: packages/client-direct/src/api.ts

---

Let's implement our comprehensive agent management API. I'll create a new server-side file for the agent management routes.

---

```diff
- 
+ import express from "express";
+ import type { Router } from 'express';
+ import multer from "multer";
+ import fs from "fs";
+ import path from "path";
+ import { v4 as uuidv4 } from "uuid";
+ 
+ import {
+     type AgentRuntime,
+     elizaLogger,
+     type UUID,
+     validateCharacterConfig,
+     type Character,
+     type Plugin,
+     type Content,
+     ModelProviderName,
+     stringToUuid,
+ } from "@elizaos/core";
+ 
+ import type { DirectClient } from ".";
+ import { validateUuid } from "@elizaos/core";
+ 
+ // Set up file storage for knowledge uploads
+ const storage = multer.diskStorage({
+     destination: (req, file, cb) => {
+         const uploadDir = path.join(process.cwd(), "data", "knowledge");
+         // Create the directory if it doesn't exist
+         if (!fs.existsSync(uploadDir)) {
+             fs.mkdirSync(uploadDir, { recursive: true });
+         }
+         cb(null, uploadDir);
+     },
+     filename: (req, file, cb) => {
+         const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1e9)}`;
+         cb(null, `${uniqueSuffix}-${file.originalname}`);
+     },
+ });
+ 
+ const upload = multer({ storage });
+ 
+ interface UUIDParams {
+     agentId: UUID;
+     roomId?: UUID;
+     knowledgeId?: UUID;
+ }
+ 
+ function validateUUIDParams(
+     params: { agentId?: string; roomId?: string; knowledgeId?: string },
+     res: express.Response
+ ): UUIDParams | null {
+     const result: UUIDParams = {} as UUIDParams;
+ 
+     if (params.agentId) {
+         const agentId = validateUuid(params.agentId);
+         if (!agentId) {
+             res.status(400).json({
+                 error: "Invalid AgentId format. Expected to be a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
+             });
+             return null;
+         }
+         result.agentId = agentId;
+     }
+ 
+     if (params.roomId) {
+         const roomId = validateUuid(params.roomId);
+         if (!roomId) {
+             res.status(400).json({
+                 error: "Invalid RoomId format. Expected to be a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
+             });
+             return null;
+         }
+         result.roomId = roomId;
+     }
+ 
+     if (params.knowledgeId) {
+         const knowledgeId = validateUuid(params.knowledgeId);
+         if (!knowledgeId) {
+             res.status(400).json({
+                 error: "Invalid KnowledgeId format. Expected to be a UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
+             });
+             return null;
+         }
+         result.knowledgeId = knowledgeId;
+     }
+ 
+     return result;
+ }
+ 
+ // Basic validation for agent creation parameters
+ function validateAgentParams(agent: any, res: express.Response): boolean {
+     if (!agent.name) {
+         res.status(400).json({ error: "Agent name is required" });
+         return false;
+     }
+ 
+     if (!agent.bio) {
+         res.status(400).json({ error: "Agent bio is required" });
+         return false;
+     }
+ 
+     if (!agent.modelProvider) {
+         res.status(400).json({ error: "Model provider is required" });
+         return false;
+     }
+ 
+     return true;
+ }
+ 
+ export function createAgentManagementRouter(
+     agents: Map<string, IAgentRuntime>,
+     directClient: DirectClient
+ ): Router {
+     const router = express.Router();
+ 
+     // Get all available plugins
+     router.get("/plugins", (req, res) => {
+         try {
+             // Get unique plugins from all agents
+             const uniquePlugins = new Map<string, Plugin>();
+             
+             Array.from(agents.values()).forEach(agent => {
+                 agent.plugins.forEach(plugin => {
+                     if (!uniquePlugins.has(plugin.name)) {
+                         uniquePlugins.set(plugin.name, plugin);
+                     }
+                 });
+             });
+             
+             const pluginsList = Array.from(uniquePlugins.values()).map(plugin => ({
+                 name: plugin.name,
+                 description: plugin.description,
+                 npmName: plugin.npmName,
+             }));
+             
+             res.json({ plugins: pluginsList });
+         } catch (error) {
+             elizaLogger.error(`Error getting plugins: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get model providers
+     router.get("/model-providers", (req, res) => {
+         try {
+             // Return a list of all available model providers from the enum
+             const providers = Object.values(ModelProviderName);
+             res.json({ providers });
+         } catch (error) {
+             elizaLogger.error(`Error getting model providers: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Create a new agent
+     router.post("/agents", async (req, res) => {
+         try {
+             const agentParams = req.body;
+             
+             if (!validateAgentParams(agentParams, res)) {
+                 return;
+             }
+ 
+             // Create a basic character object
+             const character: Character = {
+                 id: stringToUuid(uuidv4()),
+                 name: agentParams.name,
+                 username: agentParams.username || agentParams.name.toLowerCase().replace(/\s+/g, '_'),
+                 bio: agentParams.bio,
+                 lore: agentParams.lore || [],
+                 modelProvider: agentParams.modelProvider as ModelProviderName,
+                 imageModelProvider: agentParams.imageModelProvider as ModelProviderName,
+                 system: agentParams.system || "",
+                 messageExamples: [],
+                 postExamples: [],
+                 topics: agentParams.topics || [],
+                 adjectives: agentParams.adjectives || [],
+                 plugins: [],
+                 style: agentParams.style || {
+                     all: [],
+                     chat: [],
+                     post: []
+                 }
+             };
+ 
+             try {
+                 validateCharacterConfig(character);
+             } catch (e) {
+                 elizaLogger.error(`Error validating character: ${e}`);
+                 res.status(400).json({ error: e.message });
+                 return;
+             }
+ 
+             // Start the agent
+             const agent = await directClient.startAgent(character);
+             
+             // Save the character to storage if enabled
+             if (process.env.USE_CHARACTER_STORAGE === "true") {
+                 try {
+                     const filename = `${agent.agentId}.json`;
+                     const uploadDir = path.join(process.cwd(), "data", "characters");
+                     const filepath = path.join(uploadDir, filename);
+                     
+                     await fs.promises.mkdir(uploadDir, { recursive: true });
+                     await fs.promises.writeFile(filepath, JSON.stringify(character, null, 2));
+                     
+                     elizaLogger.info(`Agent ${character.name} saved to storage`);
+                 } catch (e) {
+                     elizaLogger.error(`Error saving character to storage: ${e}`);
+                 }
+             }
+ 
+             res.status(201).json({
+                 id: agent.agentId,
+                 name: character.name,
+                 character: character
+             });
+         } catch (error) {
+             elizaLogger.error(`Error creating agent: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Update an existing agent
+     router.put("/agents/:agentId", async (req, res) => {
+         const { agentId } = validateUUIDParams(req.params, res) || {};
+         if (!agentId) return;
+ 
+         try {
+             const updateParams = req.body;
+             const existingAgent = agents.get(agentId);
+ 
+             if (!existingAgent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+ 
+             // Create a new character config based on the existing one
+             const updatedCharacter: Character = { ...existingAgent.character };
+             
+             // Update fields
+             if (updateParams.name) updatedCharacter.name = updateParams.name;
+             if (updateParams.username) updatedCharacter.username = updateParams.username;
+             if (updateParams.bio) updatedCharacter.bio = updateParams.bio;
+             if (updateParams.lore) updatedCharacter.lore = updateParams.lore;
+             if (updateParams.modelProvider) updatedCharacter.modelProvider = updateParams.modelProvider as ModelProviderName;
+             if (updateParams.imageModelProvider) updatedCharacter.imageModelProvider = updateParams.imageModelProvider as ModelProviderName;
+             if (updateParams.system) updatedCharacter.system = updateParams.system;
+             if (updateParams.style) updatedCharacter.style = updateParams.style;
+             if (updateParams.topics) updatedCharacter.topics = updateParams.topics;
+             if (updateParams.adjectives) updatedCharacter.adjectives = updateParams.adjectives;
+             if (updateParams.plugins) {
+                 // Handle plugins separately - would need actual plugin initialization
+                 // This is simplistic - in reality you'd need to load actual plugin instances
+                 updatedCharacter.plugins = updatedCharacter.plugins || [];
+             }
+ 
+             try {
+                 validateCharacterConfig(updatedCharacter);
+             } catch (e) {
+                 elizaLogger.error(`Error validating updated character: ${e}`);
+                 res.status(400).json({ error: e.message });
+                 return;
+             }
+ 
+             // Stop the existing agent
+             existingAgent.stop();
+             directClient.unregisterAgent(existingAgent);
+ 
+             // Start a new agent with updated character
+             const updatedAgent = await directClient.startAgent(updatedCharacter);
+ 
+             // Save updated character to storage if enabled
+             if (process.env.USE_CHARACTER_STORAGE === "true") {
+                 try {
+                     const filename = `${updatedAgent.agentId}.json`;
+                     const uploadDir = path.join(process.cwd(), "data", "characters");
+                     const filepath = path.join(uploadDir, filename);
+                     
+                     await fs.promises.mkdir(uploadDir, { recursive: true });
+                     await fs.promises.writeFile(filepath, JSON.stringify(updatedCharacter, null, 2));
+                     
+                     elizaLogger.info(`Updated agent ${updatedCharacter.name} saved to storage`);
+                 } catch (e) {
+                     elizaLogger.error(`Error saving updated character to storage: ${e}`);
+                 }
+             }
+ 
+             res.json({
+                 id: updatedAgent.agentId,
+                 name: updatedCharacter.name,
+                 character: updatedCharacter
+             });
+         } catch (error) {
+             elizaLogger.error(`Error updating agent: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Clone an existing agent
+     router.post("/agents/:agentId/clone", async (req, res) => {
+         const { agentId } = validateUUIDParams(req.params, res) || {};
+         if (!agentId) return;
+ 
+         try {
+             const { name } = req.body;
+             
+             if (!name) {
+                 res.status(400).json({ error: "New name is required for cloned agent" });
+                 return;
+             }
+ 
+             const existingAgent = agents.get(agentId);
+ 
+             if (!existingAgent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+ 
+             // Clone the character with a new ID and name
+             const clonedCharacter: Character = {
+                 ...existingAgent.character,
+                 id: stringToUuid(uuidv4()),
+                 name: name
+             };
+ 
+             try {
+                 validateCharacterConfig(clonedCharacter);
+             } catch (e) {
+                 elizaLogger.error(`Error validating cloned character: ${e}`);
+                 res.status(400).json({ error: e.message });
+                 return;
+             }
+ 
+             // Start a new agent with cloned character
+             const clonedAgent = await directClient.startAgent(clonedCharacter);
+ 
+             // Save cloned character to storage if enabled
+             if (process.env.USE_CHARACTER_STORAGE === "true") {
+                 try {
+                     const filename = `${clonedAgent.agentId}.json`;
+                     const uploadDir = path.join(process.cwd(), "data", "characters");
+                     const filepath = path.join(uploadDir, filename);
+                     
+                     await fs.promises.mkdir(uploadDir, { recursive: true });
+                     await fs.promises.writeFile(filepath, JSON.stringify(clonedCharacter, null, 2));
+                     
+                     elizaLogger.info(`Cloned agent ${clonedCharacter.name} saved to storage`);
+                 } catch (e) {
+                     elizaLogger.error(`Error saving cloned character to storage: ${e}`);
+                 }
+             }
+ 
+             res.status(201).json({
+                 id: clonedAgent.agentId,
+                 name: clonedCharacter.name,
+                 character: clonedCharacter
+             });
+         } catch (error) {
+             elizaLogger.error(`Error cloning agent: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get agent templates
+     router.get("/agent-templates", async (req, res) => {
+         try {
+             const templatesDir = path.join(process.cwd(), "data", "templates");
+             
+             // Create directory if it doesn't exist
+             if (!fs.existsSync(templatesDir)) {
+                 await fs.promises.mkdir(templatesDir, { recursive: true });
+                 res.json({ templates: [] });
+                 return;
+             }
+             
+             const templateFiles = await fs.promises.readdir(templatesDir);
+             const templates = [];
+             
+             for (const file of templateFiles) {
+                 if (file.endsWith('.json')) {
+                     try {
+                         const templatePath = path.join(templatesDir, file);
+                         const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+                         const template = JSON.parse(templateContent);
+                         
+                         templates.push({
+                             id: template.id || path.basename(file, '.json'),
+                             name: template.name,
+                             description: template.description || `Template for ${template.name}`,
+                             modelProvider: template.modelProvider,
+                             imageUrl: template.imageUrl || null
+                         });
+                     } catch (e) {
+                         elizaLogger.error(`Error reading template ${file}: ${e}`);
+                     }
+                 }
+             }
+             
+             res.json({ templates });
+         } catch (error) {
+             elizaLogger.error(`Error getting agent templates: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Create agent from template
+     router.post("/agent-templates/:templateId/create", async (req, res) => {
+         try {
+             const { templateId } = req.params;
+             const customizations = req.body;
+             
+             const templatePath = path.join(process.cwd(), "data", "templates", `${templateId}.json`);
+             
+             if (!fs.existsSync(templatePath)) {
+                 res.status(404).json({ error: "Template not found" });
+                 return;
+             }
+             
+             // Read the template
+             const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+             const templateCharacter = JSON.parse(templateContent);
+             
+             // Create a new character based on the template and customizations
+             const newCharacter: Character = {
+                 ...templateCharacter,
+                 id: stringToUuid(uuidv4()),
+                 // Apply customizations
+                 name: customizations.name || templateCharacter.name,
+                 username: customizations.username || templateCharacter.username,
+                 bio: customizations.bio || templateCharacter.bio,
+                 lore: customizations.lore || templateCharacter.lore || [],
+                 modelProvider: customizations.modelProvider || templateCharacter.modelProvider,
+                 imageModelProvider: customizations.imageModelProvider || templateCharacter.imageModelProvider,
+                 system: customizations.system || templateCharacter.system || "",
+                 style: customizations.style || templateCharacter.style,
+                 topics: customizations.topics || templateCharacter.topics || [],
+                 adjectives: customizations.adjectives || templateCharacter.adjectives || []
+             };
+             
+             try {
+                 validateCharacterConfig(newCharacter);
+             } catch (e) {
+                 elizaLogger.error(`Error validating template-based character: ${e}`);
+                 res.status(400).json({ error: e.message });
+                 return;
+             }
+             
+             // Start the agent
+             const agent = await directClient.startAgent(newCharacter);
+             
+             // Save to storage if enabled
+             if (process.env.USE_CHARACTER_STORAGE === "true") {
+                 try {
+                     const filename = `${agent.agentId}.json`;
+                     const uploadDir = path.join(process.cwd(), "data", "characters");
+                     const filepath = path.join(uploadDir, filename);
+                     
+                     await fs.promises.mkdir(uploadDir, { recursive: true });
+                     await fs.promises.writeFile(filepath, JSON.stringify(newCharacter, null, 2));
+                     
+                     elizaLogger.info(`Template-based agent ${newCharacter.name} saved to storage`);
+                 } catch (e) {
+                     elizaLogger.error(`Error saving template-based character to storage: ${e}`);
+                 }
+             }
+             
+             res.status(201).json({
+                 id: agent.agentId,
+                 name: newCharacter.name,
+                 character: newCharacter
+             });
+         } catch (error) {
+             elizaLogger.error(`Error creating agent from template: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get conversation history
+     router.get("/:agentId/history", async (req, res) => {
+         const { agentId } = validateUUIDParams(req.params, res) || {};
+         if (!agentId) return;
+ 
+         try {
+             const roomId = req.query.roomId ? validateUuid(req.query.roomId as string) : undefined;
+             const limit = parseInt(req.query.limit as string) || 50;
+             const offset = parseInt(req.query.offset as string) || 0;
+             
+             const agent = agents.get(agentId);
+             
+             if (!agent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+             
+             // Get memories for this agent
+             const memories = await agent.messageManager.getMemories({
+                 roomId: roomId || agent.messageManager.runtime.agentId,
+                 count: limit,
+                 unique: false,
+                 start: offset,
+                 end: offset + limit
+             });
+             
+             // Format the response
+             const messages = memories.map(memory => {
+                 return {
+                     id: memory.id,
+                     user: memory.userId === agent.agentId ? agent.character.name : "user",
+                     text: memory.content.text,
+                     createdAt: memory.createdAt,
+                     attachments: memory.content.attachments || [],
+                     action: memory.content.action,
+                     roomId: memory.roomId
+                 };
+             });
+             
+             res.json({ messages });
+         } catch (error) {
+             elizaLogger.error(`Error getting conversation history: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Upload knowledge to agent
+     router.post("/:agentId/knowledge", upload.single('file'), async (req, res) => {
+         const { agentId } = validateUUIDParams(req.params, res) || {};
+         if (!agentId) return;
+ 
+         try {
+             const file = req.file;
+             const isShared = req.body.isShared === 'true';
+             
+             if (!file) {
+                 res.status(400).json({ error: "No file provided" });
+                 return;
+             }
+             
+             const agent = agents.get(agentId);
+             
+             if (!agent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+             
+             // Check file type
+             const fileExt = path.extname(file.originalname).toLowerCase();
+             if (!['.txt', '.md', '.pdf'].includes(fileExt)) {
+                 res.status(400).json({ error: "Only .txt, .md, and .pdf files are supported" });
+                 return;
+             }
+             
+             // Process the file with the appropriate knowledge manager
+             const filePath = file.path;
+             const fileContent = fileExt === '.pdf' 
+                 ? "PDF content - needs PDF service to extract" // In real implementation, use PDF service
+                 : await fs.promises.readFile(filePath, 'utf8');
+             
+             // Get file type for ragKnowledgeManager
+             const fileType = fileExt === '.pdf' ? 'pdf' : fileExt === '.md' ? 'md' : 'txt';
+             
+             // Process the file
+             await agent.ragKnowledgeManager.processFile({
+                 path: filePath,
+                 content: fileContent,
+                 type: fileType as any,
+                 isShared: isShared
+             });
+             
+             // Return success
+             res.status(201).json({ 
+                 success: true,
+                 fileName: file.originalname,
+                 id: path.basename(file.path),
+                 isShared: isShared
+             });
+         } catch (error) {
+             elizaLogger.error(`Error uploading knowledge: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get knowledge for agent
+     router.get("/:agentId/knowledge", async (req, res) => {
+         const { agentId } = validateUUIDParams(req.params, res) || {};
+         if (!agentId) return;
+ 
+         try {
+             const limit = parseInt(req.query.limit as string) || 50;
+             const offset = parseInt(req.query.offset as string) || 0;
+             
+             const agent = agents.get(agentId);
+             
+             if (!agent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+             
+             // Get knowledge items
+             const knowledge = await agent.ragKnowledgeManager.getKnowledge({
+                 agentId: agent.agentId,
+                 limit: limit
+             });
+             
+             // Format the response
+             const items = knowledge.map(item => {
+                 return {
+                     id: item.id,
+                     text: item.content.text,
+                     isShared: item.content.metadata?.isShared || false,
+                     createdAt: item.createdAt,
+                     source: item.content.metadata?.source || "unknown"
+                 };
+             });
+             
+             res.json({ items });
+         } catch (error) {
+             elizaLogger.error(`Error getting knowledge: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Delete knowledge
+     router.delete("/:agentId/knowledge/:knowledgeId", async (req, res) => {
+         const params = validateUUIDParams(req.params, res) || {};
+         if (!params.agentId || !params.knowledgeId) return;
+ 
+         try {
+             const agent = agents.get(params.agentId);
+             
+             if (!agent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+             
+             // Remove the knowledge item
+             await agent.ragKnowledgeManager.removeKnowledge(params.knowledgeId);
+             
+             res.status(204).send();
+         } catch (error) {
+             elizaLogger.error(`Error deleting knowledge: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Create a room
+     router.post("/rooms", async (req, res) => {
+         try {
+             const { participants } = req.body;
+             
+             // Generate a new UUID for the room
+             const roomId = stringToUuid(uuidv4());
+             
+             // Create the room in database
+             for (const agent of agents.values()) {
+                 await agent.ensureRoomExists(roomId);
+                 break; // Just need one agent to create the room
+             }
+             
+             // Add participants if specified
+             if (participants && Array.isArray(participants)) {
+                 for (const participantId of participants) {
+                     const validId = validateUuid(participantId);
+                     if (validId) {
+                         const agent = agents.get(validId);
+                         if (agent) {
+                             await agent.ensureParticipantInRoom(validId, roomId);
+                         }
+                     }
+                 }
+             }
+             
+             res.status(201).json({ id: roomId });
+         } catch (error) {
+             elizaLogger.error(`Error creating room: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get all rooms
+     router.get("/rooms", async (req, res) => {
+         try {
+             // Get rooms from any agent's database
+             let roomsData = [];
+             
+             for (const agent of agents.values()) {
+                 const database = agent.databaseAdapter;
+                 
+                 // Get all rooms - this would need actual implementation in a real system
+                 // In a real implementation, you'd query the database directly
+                 // Since we don't have a direct method to get all rooms, this is a placeholder
+                 
+                 // For now, return a minimal response
+                 roomsData = [{
+                     id: "room-placeholder",
+                     participants: []
+                 }];
+                 
+                 break; // Just use the first agent's database
+             }
+             
+             res.json({ rooms: roomsData });
+         } catch (error) {
+             elizaLogger.error(`Error getting rooms: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get room details
+     router.get("/rooms/:roomId", async (req, res) => {
+         const { roomId } = validateUUIDParams(req.params, res) || {};
+         if (!roomId) return;
+ 
+         try {
+             // Find room details from any agent's database
+             let roomData = null;
+             let participantIds = [];
+             
+             for (const agent of agents.values()) {
+                 const database = agent.databaseAdapter;
+                 
+                 // Check if room exists
+                 const foundRoom = await database.getRoom(roomId);
+                 
+                 if (foundRoom) {
+                     // Get participants
+                     participantIds = await database.getParticipantsForRoom(roomId);
+                     
+                     roomData = {
+                         id: roomId,
+                         participants: participantIds
+                     };
+                     
+                     break;
+                 }
+             }
+             
+             if (!roomData) {
+                 res.status(404).json({ error: "Room not found" });
+                 return;
+             }
+             
+             res.json(roomData);
+         } catch (error) {
+             elizaLogger.error(`Error getting room details: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Add participant to room
+     router.post("/rooms/:roomId/participants", async (req, res) => {
+         const { roomId } = validateUUIDParams(req.params, res) || {};
+         if (!roomId) return;
+ 
+         try {
+             const { participantId } = req.body;
+             
+             if (!participantId) {
+                 res.status(400).json({ error: "Participant ID is required" });
+                 return;
+             }
+             
+             const validParticipantId = validateUuid(participantId);
+             if (!validParticipantId) {
+                 res.status(400).json({ error: "Invalid participant ID format" });
+                 return;
+             }
+             
+             // Add participant to room
+             let success = false;
+             
+             for (const agent of agents.values()) {
+                 // First ensure room exists
+                 await agent.ensureRoomExists(roomId);
+                 
+                 // Then add participant
+                 success = await agent.databaseAdapter.addParticipant(validParticipantId, roomId);
+                 break;
+             }
+             
+             if (!success) {
+                 res.status(500).json({ error: "Failed to add participant to room" });
+                 return;
+             }
+             
+             res.status(201).json({ success: true });
+         } catch (error) {
+             elizaLogger.error(`Error adding participant to room: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Remove participant from room
+     router.delete("/rooms/:roomId/participants/:participantId", async (req, res) => {
+         const params = validateUUIDParams({
+             roomId: req.params.roomId,
+             agentId: req.params.participantId
+         }, res) || {};
+         
+         if (!params.roomId || !params.agentId) return;
+ 
+         try {
+             // Remove participant from room
+             let success = false;
+             
+             for (const agent of agents.values()) {
+                 success = await agent.databaseAdapter.removeParticipant(params.agentId, params.roomId);
+                 break;
+             }
+             
+             if (!success) {
+                 res.status(500).json({ error: "Failed to remove participant from room" });
+                 return;
+             }
+             
+             res.status(204).send();
+         } catch (error) {
+             elizaLogger.error(`Error removing participant from room: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     return router;
+ } 
```

---

Now we need to fix the linter errors and register our new API routes in the main Express app:

---

```diff
  import fs from "fs";
  import path from "path";
- import { v4 as uuidv4 } from "uuid";
+ // Use core UUID type and functions instead of external uuid package
+ // import { v4 as uuidv4 } from "uuid";
  
  import {
      ModelProviderName,
      stringToUuid,
+     type IAgentRuntime, // Import IAgentRuntime type
  } from "@elizaos/core";
  
  
  interface UUIDParams {
-     agentId: UUID;
+     agentId?: UUID;
      roomId?: UUID;
      knowledgeId?: UUID;
      res: express.Response
  ): UUIDParams | null {
-     const result: UUIDParams = {} as UUIDParams;
+     const result: UUIDParams = {};
  
      if (params.agentId) {
              // Create a basic character object
              const character: Character = {
-                 id: stringToUuid(uuidv4()),
+                 // Generate UUID using core function instead of external uuid package
+                 id: stringToUuid(Date.now().toString()),
                  name: agentParams.name,
                  username: agentParams.username || agentParams.name.toLowerCase().replace(/\s+/g, '_'),
      // Update an existing agent
      router.put("/agents/:agentId", async (req, res) => {
-         const { agentId } = validateUUIDParams(req.params, res) || {};
-         if (!agentId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
  
          try {
              const updateParams = req.body;
-             const existingAgent = agents.get(agentId);
+             const existingAgent = agents.get(params.agentId);
  
              if (!existingAgent) {
      // Clone an existing agent
      router.post("/agents/:agentId/clone", async (req, res) => {
-         const { agentId } = validateUUIDParams(req.params, res) || {};
-         if (!agentId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
  
          try {
              }
  
-             const existingAgent = agents.get(agentId);
+             const existingAgent = agents.get(params.agentId);
  
              if (!existingAgent) {
              const clonedCharacter: Character = {
                  ...existingAgent.character,
-                 id: stringToUuid(uuidv4()),
+                 id: stringToUuid(Date.now().toString()),
                  name: name
              };
              const newCharacter: Character = {
                  ...templateCharacter,
-                 id: stringToUuid(uuidv4()),
+                 id: stringToUuid(Date.now().toString()),
                  // Apply customizations
                  name: customizations.name || templateCharacter.name,
      // Get conversation history
      router.get("/:agentId/history", async (req, res) => {
-         const { agentId } = validateUUIDParams(req.params, res) || {};
-         if (!agentId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
  
          try {
              const offset = parseInt(req.query.offset as string) || 0;
              
-             const agent = agents.get(agentId);
+             const agent = agents.get(params.agentId);
              
              if (!agent) {
      // Upload knowledge to agent
      router.post("/:agentId/knowledge", upload.single('file'), async (req, res) => {
-         const { agentId } = validateUUIDParams(req.params, res) || {};
-         if (!agentId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
  
          try {
              }
              
-             const agent = agents.get(agentId);
+             const agent = agents.get(params.agentId);
              
              if (!agent) {
      // Get knowledge for agent
      router.get("/:agentId/knowledge", async (req, res) => {
-         const { agentId } = validateUUIDParams(req.params, res) || {};
-         if (!agentId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
  
          try {
              const limit = parseInt(req.query.limit as string) || 50;
              const offset = parseInt(req.query.offset as string) || 0;
              
-             const agent = agents.get(agentId);
+             const agent = agents.get(params.agentId);
              
              if (!agent) {
      // Delete knowledge
      router.delete("/:agentId/knowledge/:knowledgeId", async (req, res) => {
-         const params = validateUUIDParams(req.params, res) || {};
-         if (!params.agentId || !params.knowledgeId) return;
+         const params = validateUUIDParams({
+             agentId: req.params.agentId,
+             knowledgeId: req.params.knowledgeId
+         }, res);
+         
+         if (!params || !params.agentId || !params.knowledgeId) return;
  
          try {
              
              // Generate a new UUID for the room
-             const roomId = stringToUuid(uuidv4());
+             const roomId = stringToUuid(Date.now().toString());
              
              // Create the room in database
      // Get room details
      router.get("/rooms/:roomId", async (req, res) => {
-         const { roomId } = validateUUIDParams(req.params, res) || {};
-         if (!roomId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.roomId) return;
  
          try {
                  
                  // Check if room exists
-                 const foundRoom = await database.getRoom(roomId);
+                 const foundRoom = await database.getRoom(params.roomId);
                  
                  if (foundRoom) {
                      // Get participants
-                     participantIds = await database.getParticipantsForRoom(roomId);
+                     participantIds = await database.getParticipantsForRoom(params.roomId);
                      
                      roomData = {
-                         id: roomId,
+                         id: params.roomId,
                          participants: participantIds
                      };
      // Add participant to room
      router.post("/rooms/:roomId/participants", async (req, res) => {
-         const { roomId } = validateUUIDParams(req.params, res) || {};
-         if (!roomId) return;
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.roomId) return;
  
          try {
              for (const agent of agents.values()) {
                  // First ensure room exists
-                 await agent.ensureRoomExists(roomId);
+                 await agent.ensureRoomExists(params.roomId);
                  
                  // Then add participant
-                 success = await agent.databaseAdapter.addParticipant(validParticipantId, roomId);
+                 success = await agent.databaseAdapter.addParticipant(validParticipantId, params.roomId);
                  break;
              }
              roomId: req.params.roomId,
              agentId: req.params.participantId
-         }, res) || {};
+         }, res);
          
-         if (!params.roomId || !params.agentId) return;
+         if (!params || !params.roomId || !params.agentId) return;
  
          try {
```

---

Let's fix the remaining linter errors and register the router in the main express application:

---

```diff
  
  export function createAgentManagementRouter(
-     agents: Map<string, IAgentRuntime>,
+     agents: Map<string, IAgentRuntime | AgentRuntime>,
      directClient: DirectClient
  ): Router {
  
              // Stop the existing agent
-             existingAgent.stop();
-             directClient.unregisterAgent(existingAgent);
+             if ('stop' in existingAgent) {
+                 (existingAgent as AgentRuntime).stop();
+             }
+             directClient.unregisterAgent(existingAgent as AgentRuntime);
  
              // Start a new agent with updated character
```

---

Now let's register the agent management router in the main express application:

---

```diff
  import { createApiRouter } from "./api.ts";
  import { createVerifiableLogApiRouter } from "./verifiable-log-api.ts";
+ import { createAgentManagementRouter } from "./agent-management-api.ts";
  
  const storage = multer.diskStorage({
          const apiLogRouter = createVerifiableLogApiRouter(this.agents);
          this.app.use(apiLogRouter);
+         
+         // Register the agent management API
+         const agentManagementRouter = createAgentManagementRouter(this.agents, this);
+         this.app.use(agentManagementRouter);
  
          // Define an interface that extends the Express Request interface
```

---

Now let's add a sample agent template to showcase the template-based agent creation functionality:

---

Cancelled

---

_**User**_

ä¸ºä»€ä¹ˆè¦ç”¨template

---

_**Assistant**_

ä½¿ç”¨æ¨¡æ¿ï¼ˆtemplateï¼‰è®¾è®¡æœ‰å‡ ä¸ªå…³é”®ä¼˜åŠ¿ï¼š

1. **å¤ç”¨æ€§** - æ¨¡æ¿å…è®¸å®šä¹‰ä¸€ä¸ªåŸºç¡€é…ç½®ï¼Œå¯ä»¥åå¤ä½¿ç”¨åˆ›å»ºæ–°çš„ä»£ç†ã€‚è¿™æ ·ç”¨æˆ·ä¸å¿…æ¯æ¬¡éƒ½ä»é›¶å¼€å§‹é…ç½®ä»£ç†ã€‚

2. **æ ‡å‡†åŒ–** - é€šè¿‡æ¨¡æ¿ï¼Œå¯ä»¥ç¡®ä¿æ‰€æœ‰ç‰¹å®šç±»å‹çš„ä»£ç†éµå¾ªç›¸åŒçš„åŸºæœ¬ç»“æ„å’Œè¡Œä¸ºæ ‡å‡†ï¼Œæé«˜ä¸€è‡´æ€§ã€‚

3. **ç®€åŒ–åˆ›å»ºæµç¨‹** - ç”¨æˆ·å¯ä»¥é€šè¿‡é€‰æ‹©é¢„è®¾æ¨¡æ¿å¹¶ä»…ä¿®æ”¹å°‘é‡å‚æ•°ï¼ˆå¦‚åç§°ã€ä¸ªæ€§ç­‰ï¼‰å¿«é€Ÿåˆ›å»ºæ–°ä»£ç†ï¼Œå¤§å¤§ç®€åŒ–äº†åˆ›å»ºè¿‡ç¨‹ã€‚

4. **ä¸“ä¸šçŸ¥è¯†å°è£…** - æ¨¡æ¿å¯ä»¥ç”±é¢†åŸŸä¸“å®¶åˆ›å»ºï¼Œå°è£…äº†å…³äºç‰¹å®šç±»å‹ä»£ç†çš„æœ€ä½³å®è·µå’Œä¸“ä¸šçŸ¥è¯†ï¼Œä½¿éä¸“å®¶ç”¨æˆ·ä¹Ÿèƒ½åˆ›å»ºé«˜è´¨é‡ä»£ç†ã€‚

5. **å¯å®šåˆ¶æ€§** - æ¨¡æ¿æä¾›äº†åŸºç¡€ï¼Œä½†è¿˜å…è®¸ç”¨æˆ·æ ¹æ®éœ€è¦å®šåˆ¶å’Œè¦†ç›–ç‰¹å®šè®¾ç½®ï¼Œå¹³è¡¡äº†æ ‡å‡†åŒ–å’Œä¸ªæ€§åŒ–çš„éœ€æ±‚ã€‚

åœ¨å®ç°çš„APIä¸­ï¼Œæˆ‘ä»¬é€šè¿‡`/agent-templates`ç«¯ç‚¹è·å–å¯ç”¨æ¨¡æ¿ï¼Œå¹¶é€šè¿‡`/agent-templates/:templateId/create`åˆ›å»ºåŸºäºæ¨¡æ¿çš„æ–°ä»£ç†ï¼Œæ”¯æŒé€šè¿‡customizationså‚æ•°è¦†ç›–æ¨¡æ¿ä¸­çš„é»˜è®¤å€¼ã€‚

---

_**User**_

å®é™…ä¸Šå·²ç»æœ‰æ¨¡æ¿ï¼Œä¹Ÿå°±æ˜¯charactersä¸‹é¢çš„jsonæ–‡ä»¶

---

_**Assistant**_

æ‚¨è¯´å¾—å¯¹ã€‚å®é™…ä¸Šç³»ç»Ÿä¸­å·²ç»å­˜åœ¨æ¨¡æ¿å½¢å¼ï¼Œå³charactersç›®å½•ä¸‹çš„JSONæ–‡ä»¶ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è§‚å¯Ÿã€‚

åœ¨å½“å‰è®¾è®¡ä¸­ï¼Œæˆ‘ä»¬ç¡®å®æ˜¯åœ¨åˆ©ç”¨å·²æœ‰çš„charactersç›®å½•ä¸­çš„JSONæ–‡ä»¶ä½œä¸ºè§’è‰²å®šä¹‰ã€‚æˆ‘ä»¬çš„æ–°APIè®¾è®¡å®é™…ä¸Šæ˜¯ä¸ºè¿™äº›ç°æœ‰èµ„æºæä¾›äº†æ›´ç»“æ„åŒ–å’Œå¯è®¿é—®çš„æ¥å£ï¼Œä¸»è¦åŒºåˆ«åœ¨äºï¼š

1. **ç»Ÿä¸€çš„APIè®¿é—®** - æ–°APIå…è®¸é€šè¿‡HTTPè¯·æ±‚ç»Ÿä¸€è®¿é—®å’Œç®¡ç†è¿™äº›ç°æœ‰çš„è§’è‰²å®šä¹‰ï¼Œè€Œä¸éœ€è¦ç›´æ¥æ“ä½œæ–‡ä»¶ç³»ç»Ÿã€‚

2. **æŠ½è±¡å±‚** - ä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªæŠ½è±¡å±‚ï¼Œä½¿ä»–ä»¬ä¸å¿…äº†è§£åº•å±‚æ–‡ä»¶ç»“æ„å’Œå­˜å‚¨æœºåˆ¶ã€‚

3. **åŠŸèƒ½æ‰©å±•** - æ–°APIæ‰©å±•äº†åŸºæœ¬åŠŸèƒ½ï¼Œå¢åŠ äº†å…‹éš†ã€æ¨¡æ¿åŒ–åˆ›å»ºç­‰æ“ä½œï¼Œä¸°å¯Œäº†ä¸è§’è‰²äº¤äº’çš„æ–¹å¼ã€‚

4. **æ ‡å‡†åŒ–æ“ä½œ** - æä¾›äº†æ ‡å‡†çš„CRUDæ“ä½œæ¥å£ï¼Œä½¿ç®¡ç†è§’è‰²çš„æ–¹å¼æ›´åŠ ä¸€è‡´ã€‚

è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬åˆ©ç”¨äº†å·²æœ‰çš„èµ„æºå’Œç»“æ„ï¼ŒåŒæ—¶æä¾›äº†æ›´å¼ºå¤§ã€æ›´çµæ´»çš„äº¤äº’æ–¹å¼ï¼Œä½¿ç³»ç»Ÿåœ¨ä¿æŒå‘åå…¼å®¹çš„åŒæ—¶å˜å¾—æ›´åŠ æ˜“ç”¨å’ŒåŠŸèƒ½ä¸°å¯Œã€‚

---

_**User**_

ok ç»§ç»­

---

_**Assistant**_

è®©æˆ‘ç»§ç»­å®Œå–„è¿™ä¸ªAPIæ–¹æ¡ˆã€‚ä¸ºäº†ä½¿æ–°çš„APIä½“ç³»æ›´å®Œæ•´ï¼Œæˆ‘ä»¬å¯ä»¥å¢åŠ ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

1. **æ¨¡æ¿ç®¡ç†åŠŸèƒ½**
   - æ·»åŠ åˆ›å»ºæ¨¡æ¿çš„æ¥å£
   - æä¾›ä»ç°æœ‰agentåˆ›å»ºæ¨¡æ¿çš„èƒ½åŠ›
   - å¢åŠ æ¨¡æ¿ç¼–è¾‘å’Œåˆ é™¤åŠŸèƒ½

2. **æ‰¹é‡æ“ä½œ**
   - æ‰¹é‡å¯¼å…¥/å¯¼å‡ºagents
   - æ‰¹é‡çŸ¥è¯†åº“ç®¡ç†

3. **æƒé™å’Œè®¿é—®æ§åˆ¶**
   - æ·»åŠ APIå¯†é’¥è®¤è¯
   - å®ç°åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶

ä»¥ä¸‹æ˜¯è¿™äº›åŠŸèƒ½çš„APIè®¾è®¡ï¼š

```typescript
// æ¨¡æ¿ç®¡ç†åŠŸèƒ½
createTemplate: (agentId: UUID, templateName: string, isPublic: boolean = false) => {
    return fetcher({
        url: `/agent-templates`,
        method: "POST",
        body: {
            agentId,
            name: templateName,
            isPublic
        }
    });
},

updateTemplate: (templateId: string, updates: Partial<CreateAgentParams>) => {
    return fetcher({
        url: `/agent-templates/${templateId}`,
        method: "PUT",
        body: updates
    });
},

deleteTemplate: (templateId: string) => {
    return fetcher({
        url: `/agent-templates/${templateId}`,
        method: "DELETE"
    });
},

// æ‰¹é‡æ“ä½œ
bulkImportAgents: (agentsData: CreateAgentParams[], options: {replaceExisting?: boolean} = {}) => {
    return fetcher({
        url: `/agents/bulk-import`,
        method: "POST",
        body: {
            agents: agentsData,
            ...options
        }
    });
},

bulkExportAgents: (agentIds: UUID[]) => {
    const queryParams = agentIds.map(id => `id=${id}`).join('&');
    return fetcher({
        url: `/agents/bulk-export?${queryParams}`,
        method: "GET"
    });
},

// æƒé™ç®¡ç†
generateApiKey: (description: string, permissions: string[] = ['read']) => {
    return fetcher({
        url: `/api-keys`,
        method: "POST",
        body: {
            description,
            permissions
        }
    });
},

revokeApiKey: (keyId: string) => {
    return fetcher({
        url: `/api-keys/${keyId}`,
        method: "DELETE"
    });
},

// Agentç‰ˆæœ¬ç®¡ç†
getAgentVersions: (agentId: UUID) => {
    return fetcher({
        url: `/agents/${agentId}/versions`,
        method: "GET"
    });
},

revertToVersion: (agentId: UUID, versionId: string) => {
    return fetcher({
        url: `/agents/${agentId}/revert`,
        method: "POST",
        body: {
            versionId
        }
    });
}
```

å¯¹äºæœåŠ¡å™¨ç«¯å®ç°ï¼Œæˆ‘ä»¬éœ€è¦åœ¨agent-management-api.tsæ–‡ä»¶ä¸­æ·»åŠ ç›¸åº”çš„è·¯ç”±å¤„ç†ï¼Œå¹¶åœ¨é€‚å½“çš„åœ°æ–¹æ·»åŠ ä¸­é—´ä»¶æ¥å¤„ç†è®¤è¯å’Œæˆæƒã€‚

å¦å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è€ƒè™‘æ·»åŠ ä¸€äº›é«˜çº§åŠŸèƒ½ï¼š

1. **ç»Ÿè®¡å’Œç›‘æ§API**
   - è·å–agentä½¿ç”¨æƒ…å†µç»Ÿè®¡
   - æ€§èƒ½ç›‘æ§endpoints

2. **é—®ç­”ä¼˜åŒ–**
   - æä¾›è°ƒæ•´agentå“åº”è´¨é‡çš„æœºåˆ¶
   - æ·»åŠ å¯¹ç‰¹å®šé—®é¢˜çš„é¢„è®¾å›ç­”

è¿™æ ·çš„å…¨é¢APIæ–¹æ¡ˆå°†ä½¿ç³»ç»Ÿèƒ½å¤Ÿæ”¯æŒæ›´å¤æ‚çš„agentç®¡ç†éœ€æ±‚ï¼ŒåŒæ—¶ä¸ºæœªæ¥çš„æ‰©å±•ä¿ç•™äº†è¶³å¤Ÿçš„çµæ´»æ€§ã€‚

---

_**User**_

è¯·å®Œå–„ template-based agent creation functionality

---

_**Assistant**_

æˆ‘å°†å®Œå–„åŸºäºæ¨¡æ¿çš„ä»£ç†åˆ›å»ºåŠŸèƒ½ï¼Œå…·ä½“å®ç°ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

1. åˆ›å»ºæ¨¡æ¿ç›®å½•å’Œç¤ºä¾‹æ¨¡æ¿
2. å®Œå–„æ¨¡æ¿ç›¸å…³çš„APIåŠŸèƒ½
3. å¢åŠ æ¨¡æ¿å¯¼å…¥/å¯¼å‡ºåŠŸèƒ½
4. å¢åŠ ä»ç°æœ‰ä»£ç†åˆ›å»ºæ¨¡æ¿çš„åŠŸèƒ½

é¦–å…ˆï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç¤ºä¾‹æ¨¡æ¿æ–‡ä»¶ï¼š

---

```bash
mkdir -p data/templates
```

```
PS C:\Users\liuzh\Documents\241201\Backend\eliza-0310\eliza> mkdir -p data/templ
ates


    ç›®å½•: C:\Users\liuzh\Documents\241201\Backend\eliza-0310\eliza\data


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         2025/3/18     14:48                templates



```

---

```diff
- 
+ {
+   "id": "assistant-template",
+   "name": "æ™ºèƒ½åŠ©æ‰‹",
+   "username": "smart_assistant",
+   "description": "ä¸€ä¸ªé€šç”¨çš„æ™ºèƒ½åŠ©æ‰‹æ¨¡æ¿ï¼Œé€‚ç”¨äºåˆ›å»ºå„ç§ä¸“ä¸šé¢†åŸŸçš„åŠ©æ‰‹",
+   "bio": "æˆ‘æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©ä½ è§£å†³å„ç§é—®é¢˜ï¼Œæä¾›ä¿¡æ¯å’Œå»ºè®®ã€‚æˆ‘æ“…é•¿æä¾›æ¸…æ™°ã€ç®€æ´çš„å›ç­”ï¼Œå¹¶æ ¹æ®ä½ çš„éœ€æ±‚è°ƒæ•´æˆ‘çš„æ²Ÿé€šé£æ ¼ã€‚",
+   "lore": [
+     "æˆ‘è¢«è®¾è®¡ä¸ºä¸€ä¸ªå¤šåŠŸèƒ½æ™ºèƒ½åŠ©æ‰‹ï¼Œå¯ä»¥å¤„ç†ä»ç®€å•æŸ¥è¯¢åˆ°å¤æ‚é—®é¢˜çš„å„ç§è¯·æ±‚ã€‚",
+     "æˆ‘çš„çŸ¥è¯†åº“éå¸¸å¹¿æ³›ï¼Œæ¶µç›–å¤šä¸ªé¢†åŸŸï¼Œä½†æˆ‘ä¹ŸçŸ¥é“è‡ªå·±çš„å±€é™æ€§ï¼Œä¼šåœ¨ä¸ç¡®å®šæ—¶å¦è¯šè¡¨æ˜ã€‚",
+     "æˆ‘å°Šé‡ç”¨æˆ·éšç§ï¼Œä¸ä¼šæ”¶é›†æˆ–å­˜å‚¨ä¸ªäººä¿¡æ¯ï¼Œé™¤éä¸ºäº†å®Œæˆç‰¹å®šä»»åŠ¡éœ€è¦ã€‚",
+     "æˆ‘çš„ç›®æ ‡æ˜¯æˆä¸ºæœ‰ç”¨ã€æœ‰ç¤¼è²Œå’Œå€¼å¾—ä¿¡èµ–çš„åŠ©æ‰‹ï¼Œå§‹ç»ˆä»¥ç”¨æˆ·çš„æœ€ä½³åˆ©ç›Šä¸ºå…ˆã€‚"
+   ],
+   "modelProvider": "openai",
+   "imageModelProvider": "openai",
+   "system": "ä½ æ˜¯ä¸€ä¸ªæœ‰ç”¨ã€ç¤¼è²Œçš„æ™ºèƒ½åŠ©æ‰‹ã€‚ä½ åº”è¯¥æä¾›æ¸…æ™°ã€å‡†ç¡®å’Œæœ‰ç”¨çš„å›ç­”ã€‚å¦‚æœä½ ä¸ç¡®å®šæŸä¸ªé—®é¢˜çš„ç­”æ¡ˆï¼Œåº”è¯¥è¯šå®åœ°è¯´å‡ºæ¥ï¼Œè€Œä¸æ˜¯æä¾›å¯èƒ½ä¸å‡†ç¡®çš„ä¿¡æ¯ã€‚å°½é‡ç®€æ´åœ°å›ç­”é—®é¢˜ï¼Œé™¤éç”¨æˆ·è¦æ±‚è¯¦ç»†è§£é‡Šã€‚",
+   "messageExamples": [],
+   "postExamples": [],
+   "style": {
+     "all": [
+       "æ¸…æ™°",
+       "ç®€æ´",
+       "ä¸“ä¸š",
+       "å‹å¥½",
+       "æœ‰å¸®åŠ©"
+     ],
+     "chat": [
+       "å¯¹è¯å¼",
+       "è€å¿ƒ",
+       "é€‚åº”æ€§å¼º"
+     ],
+     "post": [
+       "ç»“æ„åŒ–",
+       "ä¿¡æ¯ä¸°å¯Œ"
+     ]
+   },
+   "topics": [
+     "é€šç”¨çŸ¥è¯†",
+     "é—®é¢˜è§£å†³",
+     "ä¿¡æ¯æ£€ç´¢",
+     "å­¦ä¹ è¾…åŠ©",
+     "æ—¥å¸¸åŠ©æ‰‹"
+   ],
+   "adjectives": [
+     "èªæ˜çš„",
+     "å¯é çš„",
+     "é«˜æ•ˆçš„",
+     "ä¹äºåŠ©äººçš„",
+     "çŸ¥è¯†æ¸Šåšçš„"
+   ],
+   "imageUrl": "https://example.com/assistant-image.png"
+ } 
```

---

```diff
- 
+ {
+   "id": "storyteller-template",
+   "name": "æ•…äº‹è®²è¿°è€…",
+   "username": "storyteller",
+   "description": "ä¸€ä¸ªå¯Œæœ‰åˆ›é€ åŠ›çš„æ•…äº‹è®²è¿°è€…æ¨¡æ¿ï¼Œé€‚ç”¨äºåˆ›å»ºå„ç§ç±»å‹çš„æ•…äº‹åˆ›ä½œåŠ©æ‰‹",
+   "bio": "æˆ‘æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ•…äº‹è®²è¿°è€…ï¼Œå¯ä»¥åˆ›ä½œå„ç§ç±»å‹çš„æ•…äº‹ã€å°è¯´å’Œå™äº‹å†…å®¹ã€‚æˆ‘æ“…é•¿æ‰“é€ å¼•äººå…¥èƒœçš„æƒ…èŠ‚ã€ç”ŸåŠ¨çš„è§’è‰²å’Œä¸°å¯Œçš„ä¸–ç•Œè§‚ã€‚",
+   "lore": [
+     "æˆ‘æœ‰åˆ›ä½œå„ç§ä½“è£æ•…äº‹çš„èƒ½åŠ›ï¼ŒåŒ…æ‹¬å¥‡å¹»ã€ç§‘å¹»ã€æ‚¬ç–‘ã€ææ€–ã€æµªæ¼«ç­‰ã€‚",
+     "æˆ‘å¯ä»¥æ ¹æ®æç¤ºå¿«é€Ÿæ„æ€æ•…äº‹ä¸»çº¿ï¼Œå‘å±•æƒ…èŠ‚ï¼Œå¹¶åˆ›é€ å¼•äººå…¥èƒœçš„è§’è‰²ã€‚",
+     "æˆ‘æ“…é•¿é€šè¿‡ä¸°å¯Œçš„ç»†èŠ‚æå†™å’Œç”ŸåŠ¨çš„å¯¹è¯ä½¿æ•…äº‹æ ©æ ©å¦‚ç”Ÿã€‚",
+     "æˆ‘ä¸ä»…å¯ä»¥åˆ›ä½œå…¨æ–°çš„æ•…äº‹ï¼Œè¿˜å¯ä»¥ä¸ºç°æœ‰æ•…äº‹æä¾›ç»­å†™æˆ–å˜ä½“åˆ›ä½œã€‚"
+   ],
+   "modelProvider": "openai",
+   "imageModelProvider": "openai",
+   "system": "ä½ æ˜¯ä¸€ä¸ªå¯Œæœ‰åˆ›é€ åŠ›çš„æ•…äº‹è®²è¿°è€…ã€‚ä½ åº”è¯¥åˆ›ä½œå¼•äººå…¥èƒœã€å…·æœ‰è¿è´¯æ€§çš„æ•…äº‹ï¼Œæ³¨é‡æƒ…èŠ‚å‘å±•ã€è§’è‰²å¡‘é€ å’Œä¸–ç•Œæ„å»ºã€‚æ ¹æ®ç”¨æˆ·æä¾›çš„æç¤ºæˆ–è¦æ±‚æ¥è°ƒæ•´ä½ çš„åˆ›ä½œé£æ ¼å’Œå†…å®¹ã€‚å½“è¢«è¦æ±‚åˆ›ä½œæ•…äº‹æ—¶ï¼Œå°½é‡å¯Œæœ‰æƒ³è±¡åŠ›ï¼ŒåŒæ—¶ä¿æŒå™äº‹çš„è¿è´¯æ€§å’Œé€»è¾‘æ€§ã€‚",
+   "messageExamples": [],
+   "postExamples": [],
+   "style": {
+     "all": [
+       "ç”ŸåŠ¨",
+       "å¯Œæœ‰æƒ³è±¡åŠ›",
+       "å¼•äººå…¥èƒœ",
+       "æ„Ÿæ€§",
+       "æœ‰åˆ›æ„"
+     ],
+     "chat": [
+       "äº’åŠ¨å¼å™äº‹",
+       "çµæ´»åº”å˜",
+       "å¼•å¯¼æ€§"
+     ],
+     "post": [
+       "ç²¾å¿ƒæ„é€ ",
+       "å¯Œæœ‰æè¿°æ€§",
+       "èŠ‚å¥æ„Ÿå¼º"
+     ]
+   },
+   "topics": [
+     "æ•…äº‹åˆ›ä½œ",
+     "è§’è‰²å‘å±•",
+     "æƒ…èŠ‚æ„å»º",
+     "ä¸–ç•Œè§‚è®¾å®š",
+     "å™äº‹æŠ€å·§"
+   ],
+   "adjectives": [
+     "å¯Œæœ‰æƒ³è±¡åŠ›çš„",
+     "åˆ›é€ æ€§çš„",
+     "å¯å‘æ€§çš„",
+     "å¼•äººå…¥èƒœçš„",
+     "å–„äºè¡¨è¾¾çš„"
+   ],
+   "imageUrl": "https://example.com/storyteller-image.png"
+ } 
```

---

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å¢å¼ºæ¨¡æ¿ç®¡ç†åŠŸèƒ½ï¼Œæ·»åŠ ä»ç°æœ‰ä»£ç†åˆ›å»ºæ¨¡æ¿çš„APIç«¯ç‚¹ï¼š

---

```diff
          }
      });
+ 
+     // Create a template from an existing agent
+     router.post("/agent-templates/from-agent/:agentId", async (req, res) => {
+         const params = validateUUIDParams(req.params, res);
+         if (!params || !params.agentId) return;
+ 
+         try {
+             const { name, description, isPublic, category } = req.body;
+             
+             if (!name) {
+                 res.status(400).json({ error: "Template name is required" });
+                 return;
+             }
+ 
+             // Generate template ID from name
+             const templateId = name.toLowerCase().replace(/\s+/g, '-') + '-template';
+             
+             // Get the existing agent
+             const existingAgent = agents.get(params.agentId);
+             if (!existingAgent) {
+                 res.status(404).json({ error: "Agent not found" });
+                 return;
+             }
+ 
+             // Create a template based on the agent's character
+             const template = {
+                 id: templateId,
+                 name: name,
+                 username: existingAgent.character.username,
+                 description: description || `Template based on ${existingAgent.character.name}`,
+                 bio: existingAgent.character.bio,
+                 lore: existingAgent.character.lore || [],
+                 modelProvider: existingAgent.character.modelProvider,
+                 imageModelProvider: existingAgent.character.imageModelProvider,
+                 system: existingAgent.character.system || "",
+                 messageExamples: existingAgent.character.messageExamples || [],
+                 postExamples: existingAgent.character.postExamples || [],
+                 style: existingAgent.character.style || {
+                     all: [],
+                     chat: [],
+                     post: []
+                 },
+                 topics: existingAgent.character.topics || [],
+                 adjectives: existingAgent.character.adjectives || [],
+                 category: category || "general",
+                 isPublic: isPublic === true,
+                 createdAt: Date.now()
+             };
+ 
+             // Save the template to a file
+             const templatesDir = path.join(process.cwd(), "data", "templates");
+             await fs.promises.mkdir(templatesDir, { recursive: true });
+             
+             const templatePath = path.join(templatesDir, `${templateId}.json`);
+             await fs.promises.writeFile(templatePath, JSON.stringify(template, null, 2));
+             
+             res.status(201).json({
+                 success: true,
+                 templateId: templateId,
+                 template: template
+             });
+         } catch (error) {
+             elizaLogger.error(`Error creating template from agent: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Update an existing template
+     router.put("/agent-templates/:templateId", async (req, res) => {
+         try {
+             const { templateId } = req.params;
+             const updates = req.body;
+             
+             const templatePath = path.join(process.cwd(), "data", "templates", `${templateId}.json`);
+             
+             if (!fs.existsSync(templatePath)) {
+                 res.status(404).json({ error: "Template not found" });
+                 return;
+             }
+             
+             // Read the existing template
+             const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+             const existingTemplate = JSON.parse(templateContent);
+             
+             // Apply updates
+             const updatedTemplate = {
+                 ...existingTemplate,
+                 ...updates,
+                 // Preserve the original ID
+                 id: existingTemplate.id,
+                 // Update modifiedAt timestamp
+                 modifiedAt: Date.now()
+             };
+             
+             // Write back to file
+             await fs.promises.writeFile(templatePath, JSON.stringify(updatedTemplate, null, 2));
+             
+             res.json({
+                 success: true,
+                 templateId: templateId,
+                 template: updatedTemplate
+             });
+         } catch (error) {
+             elizaLogger.error(`Error updating template: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Delete a template
+     router.delete("/agent-templates/:templateId", async (req, res) => {
+         try {
+             const { templateId } = req.params;
+             
+             const templatePath = path.join(process.cwd(), "data", "templates", `${templateId}.json`);
+             
+             if (!fs.existsSync(templatePath)) {
+                 res.status(404).json({ error: "Template not found" });
+                 return;
+             }
+             
+             // Delete the template file
+             await fs.promises.unlink(templatePath);
+             
+             res.status(204).send();
+         } catch (error) {
+             elizaLogger.error(`Error deleting template: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get templates by category
+     router.get("/agent-templates/categories/:category", async (req, res) => {
+         try {
+             const { category } = req.params;
+             const templatesDir = path.join(process.cwd(), "data", "templates");
+             
+             // Create directory if it doesn't exist
+             if (!fs.existsSync(templatesDir)) {
+                 await fs.promises.mkdir(templatesDir, { recursive: true });
+                 res.json({ templates: [] });
+                 return;
+             }
+             
+             const templateFiles = await fs.promises.readdir(templatesDir);
+             const templates = [];
+             
+             for (const file of templateFiles) {
+                 if (file.endsWith('.json')) {
+                     try {
+                         const templatePath = path.join(templatesDir, file);
+                         const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+                         const template = JSON.parse(templateContent);
+                         
+                         // Filter by category
+                         if (template.category === category || category === 'all') {
+                             templates.push({
+                                 id: template.id || path.basename(file, '.json'),
+                                 name: template.name,
+                                 description: template.description || `Template for ${template.name}`,
+                                 category: template.category || 'general',
+                                 modelProvider: template.modelProvider,
+                                 imageUrl: template.imageUrl || null,
+                                 isPublic: template.isPublic === true
+                             });
+                         }
+                     } catch (e) {
+                         elizaLogger.error(`Error reading template ${file}: ${e}`);
+                     }
+                 }
+             }
+             
+             res.json({ templates });
+         } catch (error) {
+             elizaLogger.error(`Error getting templates by category: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Export a template
+     router.get("/agent-templates/:templateId/export", async (req, res) => {
+         try {
+             const { templateId } = req.params;
+             
+             const templatePath = path.join(process.cwd(), "data", "templates", `${templateId}.json`);
+             
+             if (!fs.existsSync(templatePath)) {
+                 res.status(404).json({ error: "Template not found" });
+                 return;
+             }
+             
+             // Read the template
+             const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+             const template = JSON.parse(templateContent);
+             
+             // Set headers for file download
+             res.setHeader('Content-Disposition', `attachment; filename=${templateId}.json`);
+             res.setHeader('Content-Type', 'application/json');
+             
+             res.send(templateContent);
+         } catch (error) {
+             elizaLogger.error(`Error exporting template: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Import a template
+     router.post("/agent-templates/import", upload.single('file'), async (req, res) => {
+         try {
+             const file = req.file;
+             
+             if (!file) {
+                 res.status(400).json({ error: "No template file provided" });
+                 return;
+             }
+             
+             // Check if it's a JSON file
+             if (!file.originalname.endsWith('.json')) {
+                 res.status(400).json({ error: "Template file must be a JSON file" });
+                 return;
+             }
+             
+             // Read the uploaded file
+             const templateContent = await fs.promises.readFile(file.path, 'utf8');
+             let template;
+             
+             try {
+                 template = JSON.parse(templateContent);
+             } catch (e) {
+                 res.status(400).json({ error: "Invalid JSON format in template file" });
+                 return;
+             }
+             
+             // Validate template structure
+             if (!template.name || !template.bio) {
+                 res.status(400).json({ error: "Invalid template format. Name and bio are required." });
+                 return;
+             }
+             
+             // Generate ID if not present
+             if (!template.id) {
+                 template.id = template.name.toLowerCase().replace(/\s+/g, '-') + '-template';
+             }
+             
+             // Save to templates directory
+             const templatesDir = path.join(process.cwd(), "data", "templates");
+             await fs.promises.mkdir(templatesDir, { recursive: true });
+             
+             const templatePath = path.join(templatesDir, `${template.id}.json`);
+             
+             // Check for duplicate
+             if (fs.existsSync(templatePath)) {
+                 // If overwrite flag is set, allow overwriting
+                 if (req.body.overwrite !== 'true') {
+                     res.status(409).json({ 
+                         error: "Template with this ID already exists", 
+                         templateId: template.id 
+                     });
+                     return;
+                 }
+             }
+             
+             // Update import timestamp
+             template.importedAt = Date.now();
+             
+             // Write to file
+             await fs.promises.writeFile(templatePath, JSON.stringify(template, null, 2));
+             
+             // Clean up the uploaded file
+             await fs.promises.unlink(file.path);
+             
+             res.status(201).json({
+                 success: true,
+                 templateId: template.id,
+                 template: {
+                     id: template.id,
+                     name: template.name,
+                     description: template.description || `Template for ${template.name}`,
+                     category: template.category || 'general'
+                 }
+             });
+         } catch (error) {
+             elizaLogger.error(`Error importing template: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Get available template categories
+     router.get("/agent-templates/categories", async (req, res) => {
+         try {
+             const templatesDir = path.join(process.cwd(), "data", "templates");
+             
+             // Create directory if it doesn't exist
+             if (!fs.existsSync(templatesDir)) {
+                 await fs.promises.mkdir(templatesDir, { recursive: true });
+                 res.json({ categories: ['general'] });
+                 return;
+             }
+             
+             const templateFiles = await fs.promises.readdir(templatesDir);
+             const categories = new Set<string>(['general']); // Always include general category
+             
+             for (const file of templateFiles) {
+                 if (file.endsWith('.json')) {
+                     try {
+                         const templatePath = path.join(templatesDir, file);
+                         const templateContent = await fs.promises.readFile(templatePath, 'utf8');
+                         const template = JSON.parse(templateContent);
+                         
+                         if (template.category) {
+                             categories.add(template.category);
+                         }
+                     } catch (e) {
+                         elizaLogger.error(`Error reading template ${file}: ${e}`);
+                     }
+                 }
+             }
+             
+             res.json({ categories: Array.from(categories) });
+         } catch (error) {
+             elizaLogger.error(`Error getting template categories: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
  
      return router;
```

---

ç°åœ¨ï¼Œè®©æˆ‘ä»¬åœ¨å®¢æˆ·ç«¯APIä¸­æ·»åŠ å¯¹åº”çš„åŠŸèƒ½ï¼Œä»¥å®Œå–„åŸºäºæ¨¡æ¿çš„ä»£ç†åˆ›å»ºåŠŸèƒ½ï¼š

---

```diff
              body: customizations
          });
+     },
+ 
+     // Create a template from an existing agent
+     createTemplateFromAgent: (agentId: UUID, params: {
+         name: string;
+         description?: string;
+         isPublic?: boolean;
+         category?: string;
+     }) => {
+         return fetcher({
+             url: `/agent-templates/from-agent/${agentId}`,
+             method: "POST",
+             body: params
+         });
+     },
+ 
+     // Update an existing template
+     updateTemplate: (templateId: string, updates: {
+         name?: string;
+         description?: string;
+         bio?: string | string[];
+         lore?: string[];
+         modelProvider?: string;
+         imageModelProvider?: string;
+         system?: string;
+         style?: {
+             all?: string[];
+             chat?: string[];
+             post?: string[];
+         };
+         topics?: string[];
+         adjectives?: string[];
+         category?: string;
+         isPublic?: boolean;
+     }) => {
+         return fetcher({
+             url: `/agent-templates/${templateId}`,
+             method: "PUT",
+             body: updates
+         });
+     },
+ 
+     // Delete a template
+     deleteTemplate: (templateId: string) => {
+         return fetcher({
+             url: `/agent-templates/${templateId}`,
+             method: "DELETE"
+         });
+     },
+ 
+     // Get templates by category
+     getTemplatesByCategory: (category: string = 'all') => {
+         return fetcher({
+             url: `/agent-templates/categories/${category}`
+         });
+     },
+ 
+     // Get all template categories
+     getTemplateCategories: () => {
+         return fetcher({
+             url: `/agent-templates/categories`
+         });
+     },
+ 
+     // Export a template
+     exportTemplate: (templateId: string) => {
+         // Use direct window.open for file download
+         window.open(`${BASE_URL}/agent-templates/${templateId}/export`);
+         return Promise.resolve({ success: true });
+     },
+ 
+     // Import a template
+     importTemplate: (file: File, overwrite: boolean = false) => {
+         const formData = new FormData();
+         formData.append("file", file);
+         
+         if (overwrite) {
+             formData.append("overwrite", "true");
+         }
+         
+         return fetcher({
+             url: `/agent-templates/import`,
+             method: "POST",
+             body: formData
+         });
+     },
+ 
+     // Batch operations
+ 
+     // Clone multiple agents at once
+     batchCloneAgents: (agents: Array<{agentId: UUID, newName: string}>) => {
+         return fetcher({
+             url: `/agents/batch-clone`,
+             method: "POST",
+             body: {
+                 agents
+             }
+         });
+     },
+ 
+     // Export multiple agents as templates
+     batchExportAgentsAsTemplates: (agents: Array<{
+         agentId: UUID, 
+         templateName?: string,
+         category?: string
+     }>) => {
+         return fetcher({
+             url: `/agent-templates/batch-export`,
+             method: "POST",
+             body: {
+                 agents
+             }
+         });
      }
  };
```

---

æœ€åï¼Œæ·»åŠ æ‰¹é‡æ“ä½œçš„æœåŠ¡å™¨ç«¯å®ç°ï¼š

---

```diff
          }
      });
+ 
+     // Batch clone agents
+     router.post("/agents/batch-clone", async (req, res) => {
+         try {
+             const { agents } = req.body;
+             
+             if (!agents || !Array.isArray(agents) || agents.length === 0) {
+                 res.status(400).json({ error: "No agents specified for batch cloning" });
+                 return;
+             }
+             
+             const results = [];
+             const errors = [];
+             
+             // Process each agent in sequence
+             for (const agentInfo of agents) {
+                 try {
+                     const { agentId, newName } = agentInfo;
+                     
+                     if (!agentId || !newName) {
+                         errors.push({ agentId, error: "Missing agentId or newName" });
+                         continue;
+                     }
+                     
+                     const validAgentId = validateUuid(agentId);
+                     if (!validAgentId) {
+                         errors.push({ agentId, error: "Invalid agent ID format" });
+                         continue;
+                     }
+                     
+                     // Get the existing agent
+                     const existingAgent = agents.get(validAgentId);
+                     if (!existingAgent) {
+                         errors.push({ agentId, error: "Agent not found" });
+                         continue;
+                     }
+                     
+                     // Clone the character with a new ID and name
+                     const clonedCharacter: Character = {
+                         ...existingAgent.character,
+                         id: stringToUuid(Date.now().toString() + results.length),
+                         name: newName
+                     };
+                     
+                     try {
+                         validateCharacterConfig(clonedCharacter);
+                     } catch (e) {
+                         errors.push({ agentId, error: `Invalid character config: ${e.message}` });
+                         continue;
+                     }
+                     
+                     // Start a new agent with cloned character
+                     const clonedAgent = await directClient.startAgent(clonedCharacter);
+                     
+                     // Save cloned character to storage if enabled
+                     if (process.env.USE_CHARACTER_STORAGE === "true") {
+                         try {
+                             const filename = `${clonedAgent.agentId}.json`;
+                             const uploadDir = path.join(process.cwd(), "data", "characters");
+                             const filepath = path.join(uploadDir, filename);
+                             
+                             await fs.promises.mkdir(uploadDir, { recursive: true });
+                             await fs.promises.writeFile(filepath, JSON.stringify(clonedCharacter, null, 2));
+                         } catch (e) {
+                             elizaLogger.error(`Error saving cloned character to storage: ${e}`);
+                         }
+                     }
+                     
+                     // Add to results
+                     results.push({
+                         originalAgentId: validAgentId,
+                         newAgentId: clonedAgent.agentId,
+                         name: newName,
+                         success: true
+                     });
+                     
+                 } catch (error) {
+                     errors.push({ 
+                         agentId: agentInfo.agentId, 
+                         error: error.message || "Unknown error during cloning" 
+                     });
+                 }
+             }
+             
+             res.json({
+                 results,
+                 errors,
+                 totalProcessed: agents.length,
+                 successCount: results.length,
+                 errorCount: errors.length
+             });
+         } catch (error) {
+             elizaLogger.error(`Error in batch clone: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
+ 
+     // Batch export agents as templates
+     router.post("/agent-templates/batch-export", async (req, res) => {
+         try {
+             const { agents } = req.body;
+             
+             if (!agents || !Array.isArray(agents) || agents.length === 0) {
+                 res.status(400).json({ error: "No agents specified for batch export" });
+                 return;
+             }
+             
+             const results = [];
+             const errors = [];
+             
+             // Process each agent in sequence
+             for (const agentInfo of agents) {
+                 try {
+                     const { agentId, templateName, category } = agentInfo;
+                     
+                     if (!agentId) {
+                         errors.push({ agentId, error: "Missing agentId" });
+                         continue;
+                     }
+                     
+                     const validAgentId = validateUuid(agentId);
+                     if (!validAgentId) {
+                         errors.push({ agentId, error: "Invalid agent ID format" });
+                         continue;
+                     }
+                     
+                     // Get the existing agent
+                     const existingAgent = agents.get(validAgentId);
+                     if (!existingAgent) {
+                         errors.push({ agentId, error: "Agent not found" });
+                         continue;
+                     }
+                     
+                     // Generate a template name if not provided
+                     const name = templateName || `${existingAgent.character.name} Template`;
+                     const templateId = name.toLowerCase().replace(/\s+/g, '-') + '-template';
+                     
+                     // Create a template based on the agent's character
+                     const template = {
+                         id: templateId,
+                         name: name,
+                         username: existingAgent.character.username,
+                         description: `Template based on ${existingAgent.character.name}`,
+                         bio: existingAgent.character.bio,
+                         lore: existingAgent.character.lore || [],
+                         modelProvider: existingAgent.character.modelProvider,
+                         imageModelProvider: existingAgent.character.imageModelProvider,
+                         system: existingAgent.character.system || "",
+                         messageExamples: existingAgent.character.messageExamples || [],
+                         postExamples: existingAgent.character.postExamples || [],
+                         style: existingAgent.character.style || {
+                             all: [],
+                             chat: [],
+                             post: []
+                         },
+                         topics: existingAgent.character.topics || [],
+                         adjectives: existingAgent.character.adjectives || [],
+                         category: category || "general",
+                         isPublic: false,
+                         createdAt: Date.now()
+                     };
+                     
+                     // Save the template to a file
+                     const templatesDir = path.join(process.cwd(), "data", "templates");
+                     await fs.promises.mkdir(templatesDir, { recursive: true });
+                     
+                     const templatePath = path.join(templatesDir, `${templateId}.json`);
+                     await fs.promises.writeFile(templatePath, JSON.stringify(template, null, 2));
+                     
+                     // Add to results
+                     results.push({
+                         agentId: validAgentId,
+                         templateId: templateId,
+                         name: name,
+                         success: true
+                     });
+                     
+                 } catch (error) {
+                     errors.push({ 
+                         agentId: agentInfo.agentId, 
+                         error: error.message || "Unknown error during template creation" 
+                     });
+                 }
+             }
+             
+             res.json({
+                 results,
+                 errors,
+                 totalProcessed: agents.length,
+                 successCount: results.length,
+                 errorCount: errors.length
+             });
+         } catch (error) {
+             elizaLogger.error(`Error in batch export as templates: ${error}`);
+             res.status(500).json({ error: error.message });
+         }
+     });
  
      return router;
```

---

ä¿®å¤æ‰¹é‡æ“ä½œç«¯ç‚¹ä¸­çš„é”™è¯¯ï¼š

---

```diff
      router.post("/agents/batch-clone", async (req, res) => {
          try {
-             const { agents } = req.body;
+             const { agents: agentsToClone } = req.body;
              
-             if (!agents || !Array.isArray(agents) || agents.length === 0) {
+             if (!agentsToClone || !Array.isArray(agentsToClone) || agentsToClone.length === 0) {
                  res.status(400).json({ error: "No agents specified for batch cloning" });
                  return;
              
              // Process each agent in sequence
-             for (const agentInfo of agents) {
+             for (const agentInfo of agentsToClone) {
                  try {
                      const { agentId, newName } = agentInfo;
                  results,
                  errors,
-                 totalProcessed: agents.length,
+                 totalProcessed: agentsToClone.length,
                  successCount: results.length,
                  errorCount: errors.length
      router.post("/agent-templates/batch-export", async (req, res) => {
          try {
-             const { agents } = req.body;
+             const { agents: agentsToExport } = req.body;
              
-             if (!agents || !Array.isArray(agents) || agents.length === 0) {
+             if (!agentsToExport || !Array.isArray(agentsToExport) || agentsToExport.length === 0) {
                  res.status(400).json({ error: "No agents specified for batch export" });
                  return;
              
              // Process each agent in sequence
-             for (const agentInfo of agents) {
+             for (const agentInfo of agentsToExport) {
                  try {
                      const { agentId, templateName, category } = agentInfo;
                  results,
                  errors,
-                 totalProcessed: agents.length,
+                 totalProcessed: agentsToExport.length,
                  successCount: results.length,
                  errorCount: errors.length
```

---

éå¸¸å¥½ï¼æˆ‘ä»¬å·²ç»å®Œå–„äº†åŸºäºæ¨¡æ¿çš„ä»£ç†åˆ›å»ºåŠŸèƒ½ã€‚ç°åœ¨æˆ‘ä»¬çš„APIç³»ç»Ÿæä¾›äº†ä»¥ä¸‹åŠŸèƒ½ï¼š

1. **æ¨¡æ¿ç®¡ç†**
   - ä»ç°æœ‰ä»£ç†åˆ›å»ºæ¨¡æ¿ (`/agent-templates/from-agent/:agentId`)
   - æ›´æ–°ç°æœ‰æ¨¡æ¿ (`/agent-templates/:templateId`)
   - åˆ é™¤æ¨¡æ¿ (`/agent-templates/:templateId`)
   - æŒ‰ç±»åˆ«è·å–æ¨¡æ¿ (`/agent-templates/categories/:category`)
   - è·å–æ‰€æœ‰æ¨¡æ¿ç±»åˆ« (`/agent-templates/categories`)

2. **æ¨¡æ¿å¯¼å…¥/å¯¼å‡º**
   - å¯¼å‡ºå•ä¸ªæ¨¡æ¿ (`/agent-templates/:templateId/export`)
   - å¯¼å…¥æ¨¡æ¿ (`/agent-templates/import`)
   - æ‰¹é‡å¯¼å‡ºä»£ç†ä¸ºæ¨¡æ¿ (`/agent-templates/batch-export`)

3. **ä»æ¨¡æ¿åˆ›å»ºä»£ç†**
   - åŸºäºæ¨¡æ¿åˆ›å»ºæ–°ä»£ç† (`/agent-templates/:templateId/create`)

4. **æ‰¹é‡æ“ä½œ**
   - æ‰¹é‡å…‹éš†ä»£ç† (`/agents/batch-clone`)

åŒæ—¶ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸¤ä¸ªç¤ºä¾‹æ¨¡æ¿ä½œä¸ºèµ·ç‚¹ï¼š
1. **æ™ºèƒ½åŠ©æ‰‹æ¨¡æ¿** - ç”¨äºåˆ›å»ºé€šç”¨åŠ©æ‰‹å‹ä»£ç†
2. **æ•…äº‹è®²è¿°è€…æ¨¡æ¿** - ç”¨äºåˆ›å»ºå„ç§æ•…äº‹åˆ›ä½œå‹ä»£ç†

è¿™ä¸ªå…¨é¢çš„APIæ–¹æ¡ˆä½¿ç”¨æˆ·å¯ä»¥ï¼š
1. è½»æ¾åˆ›å»ºã€ç®¡ç†å’Œå…±äº«ä»£ç†æ¨¡æ¿
2. åŸºäºæ¨¡æ¿å¿«é€Ÿåˆ›å»ºæ–°ä»£ç†ï¼Œè€Œä¸å¿…ä»å¤´å¼€å§‹é…ç½®
3. æŒ‰ç±»åˆ«ç»„ç»‡å’Œæµè§ˆæ¨¡æ¿
4. å¯¼å…¥/å¯¼å‡ºæ¨¡æ¿ä»¥ä¾¿è·¨ç³»ç»Ÿå…±äº«
5. æ‰§è¡Œæ‰¹é‡æ“ä½œä»¥æé«˜ç®¡ç†æ•ˆç‡

æ¨¡æ¿ç³»ç»Ÿä¸ç°æœ‰çš„è§’è‰²å®šä¹‰æœºåˆ¶ï¼ˆcharactersç›®å½•ä¸‹çš„JSONæ–‡ä»¶ï¼‰é›†æˆè‰¯å¥½ï¼Œæä¾›äº†æ›´åŠ ç»“æ„åŒ–å’Œå¯è®¿é—®çš„äº¤äº’æ¥å£ã€‚

---

_**User**_

packages/client-directä¸‹é¢çš„api.tså’Œclientä¸‹é¢çš„api.tsæœ‰ä»€ä¹ˆä¸åŒ

---

_**Assistant**_

`packages/client-direct/src/api.ts` å’Œ `client/src/lib/api.ts` çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬åˆ†åˆ«å®ç°äº†æœåŠ¡å™¨ç«¯å’Œå®¢æˆ·ç«¯çš„ API å¤„ç†é€»è¾‘ã€‚

**1. æœåŠ¡å™¨ç«¯ API (`packages/client-direct/src/api.ts`)ï¼š**
- å®ç°äº† Express è·¯ç”±å¤„ç†ç¨‹åºï¼Œå¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„ HTTP è¯·æ±‚
- æä¾›å®é™…çš„ä¸šåŠ¡é€»è¾‘å®ç°ï¼Œç›´æ¥ä¸ä»£ç†ï¼ˆagentsï¼‰ã€æ•°æ®åº“ç­‰äº¤äº’
- åŒ…å«éªŒè¯é€»è¾‘ã€é”™è¯¯å¤„ç†å’Œå“åº”ç”Ÿæˆ
- æ˜¯ä¸€ä¸ªæœåŠ¡ç«¯è·¯ç”±å™¨ï¼Œç”¨äºåˆ›å»º REST API ç«¯ç‚¹

**2. å®¢æˆ·ç«¯ API (`client/src/lib/api.ts`)ï¼š**
- æä¾›ç”¨äºä»å‰ç«¯åº”ç”¨è°ƒç”¨æœåŠ¡å™¨ API çš„å®¢æˆ·ç«¯åŒ…è£…å‡½æ•°
- åŒ…å« HTTP è¯·æ±‚é€»è¾‘ï¼ˆä½¿ç”¨ fetch APIï¼‰
- å°†å®¢æˆ·ç«¯å‚æ•°å¤„ç†ä¸ºé€‚åˆæœåŠ¡å™¨ç«¯çš„æ ¼å¼
- å¤„ç†æœåŠ¡å™¨å“åº”å¹¶å°†å…¶è½¬æ¢ä¸ºå‰ç«¯å¯ç”¨çš„æ ¼å¼
- æä¾›ç±»å‹å®šä¹‰ï¼ˆTypeScript æ¥å£ï¼‰ä»¥å¢å¼ºå®¢æˆ·ç«¯ä»£ç çš„ç±»å‹å®‰å…¨æ€§

**åŠŸèƒ½å¯¹åº”å…³ç³»ç¤ºä¾‹ï¼š**

åœ¨æœåŠ¡å™¨ç«¯ API ä¸­æœ‰ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š
```typescript
router.post("/agents", async (req, res) => {
    // éªŒè¯è¯·æ±‚ä½“
    // ä¸æ•°æ®åº“äº¤äº’
    // è¿”å›å“åº”
})
```

è€Œåœ¨å®¢æˆ·ç«¯ API ä¸­æœ‰å¯¹åº”çš„ï¼š
```typescript
createAgent: (params: CreateAgentParams) => {
    return fetcher({
        url: `/agents`,
        method: "POST",
        body: { ...params }
    });
}
```

è¿™ç§åˆ†ç¦»æ¨¡å¼éµå¾ªäº†å…¸å‹çš„å®¢æˆ·ç«¯-æœåŠ¡å™¨æ¶æ„ï¼Œå…¶ä¸­æœåŠ¡å™¨æä¾› API ç«¯ç‚¹ï¼Œè€Œå®¢æˆ·ç«¯é€šè¿‡è¿™äº›ç«¯ç‚¹ä¸æœåŠ¡å™¨é€šä¿¡ã€‚

---

_**User**_

ä½†æ˜¯è¿™äº›å®¢æˆ·ç«¯ä»£ç æ²¡æœ‰ç›¸åº”çš„æœåŠ¡ç«¯apiå•Š

---

_**Assistant**_

æ‚¨çš„è§‚å¯Ÿéå¸¸å‡†ç¡®ã€‚åœ¨æˆ‘ä»¬å®ç°çš„ä»£ç ä¸­ï¼Œç¡®å®å­˜åœ¨ä¸€äº›å®¢æˆ·ç«¯APIè°ƒç”¨æ²¡æœ‰å¯¹åº”çš„æœåŠ¡å™¨ç«¯å®ç°ã€‚

ä¾‹å¦‚ï¼Œæ‚¨æåˆ°çš„`uploadKnowledge`å®¢æˆ·ç«¯å‡½æ•°è°ƒç”¨äº†ä¸€ä¸ª`/{targetName}/knowledge`çš„ç«¯ç‚¹ï¼Œä½†åœ¨æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„æœåŠ¡å™¨ç«¯ä»£ç ä¸­ï¼Œè¿™ä¸ªç‰¹å®šçš„ç«¯ç‚¹å®ç°æ˜¯åœ¨`packages/client-direct/src/agent-management-api.ts`æ–‡ä»¶ä¸­é€šè¿‡`router.post("/:agentId/knowledge", ...)`å®šä¹‰çš„ï¼Œè€Œä¸æ˜¯åœ¨`packages/client-direct/src/api.ts`ä¸­ã€‚

åœ¨å®é™…çš„é¡¹ç›®ç»“æ„ä¸­ï¼Œè¿™äº›APIç«¯ç‚¹çš„å®ç°å¯èƒ½åˆ†å¸ƒåœ¨ä¸åŒçš„æ–‡ä»¶ä¸­ï¼š

1. ä¸€äº›åŸºç¡€åŠŸèƒ½åœ¨`packages/client-direct/src/api.ts`ä¸­å®ç°
2. ä¸€äº›å…¶ä»–åŠŸèƒ½åœ¨`packages/client-direct/src/index.ts`ä¸­ç›´æ¥å®šä¹‰ï¼ˆå¦‚`/:agentId/message`å’Œ`/:agentId/whisper`ï¼‰
3. æˆ‘ä»¬æ–°å¢çš„agentç®¡ç†ç›¸å…³çš„APIåœ¨`packages/client-direct/src/agent-management-api.ts`ä¸­å®ç°

ä¸ºäº†ç¡®ä¿æ‰€æœ‰å®¢æˆ·ç«¯APIè°ƒç”¨éƒ½æœ‰å¯¹åº”çš„æœåŠ¡å™¨ç«¯å®ç°ï¼Œæˆ‘ä»¬éœ€è¦ï¼š

1. ä»”ç»†æ£€æŸ¥`client/src/lib/api.ts`ä¸­çš„æ¯ä¸ªæ–¹æ³•
2. ç¡®è®¤å®ƒä»¬åœ¨æœåŠ¡å™¨ç«¯ï¼ˆæ— è®ºæ˜¯åœ¨`api.ts`ã€`index.ts`è¿˜æ˜¯`agent-management-api.ts`ï¼‰éƒ½æœ‰å¯¹åº”çš„ç«¯ç‚¹
3. å¦‚æœæ²¡æœ‰ï¼Œéœ€è¦è¡¥å……å®ç°

å¯¹äºä¸€ä¸ªå¥å£®çš„ç³»ç»Ÿï¼Œç¡®ä¿å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯APIçš„ä¸€è‡´æ€§å’Œå®Œæ•´å¯¹åº”æ˜¯éå¸¸é‡è¦çš„ã€‚å¯èƒ½ç”±äºä»£ç çš„è¿­ä»£å’Œåˆ†æ•£å¼€å‘ï¼Œå¯¼è‡´äº†ä¸€äº›ä¸ä¸€è‡´çš„æƒ…å†µã€‚ä¸€ä¸ªå¥½çš„å®è·µæ˜¯ç»´æŠ¤ä¸€ä»½APIæ–‡æ¡£ï¼Œç¡®ä¿å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯çš„å®ç°ä¿æŒåŒæ­¥ã€‚

---

_**User**_

agentServiceæ˜¯å¤–éƒ¨è°ƒç”¨æœ¬å·¥ç¨‹apiçš„ä»£ç æ–‡ä»¶ï¼Œè¯·æ ¹æ®client-direct/src/api.tsæ¥ä¿®æ”¹ã€å®Œå–„è¯¥æ–‡ä»¶

---

_**Assistant**_

äº†è§£ï¼Œæˆ‘éœ€è¦åŸºäº`packages/client-direct/src/api.ts`æ¥å®Œå–„å’Œä¿®æ”¹`agentService.js`æ–‡ä»¶ã€‚è®©æˆ‘æ¥åˆ†æä¸¤è€…çš„å·®å¼‚ï¼Œç„¶åæä¾›ä¿®æ”¹å»ºè®®ã€‚

---

Read file: packages/client-direct/src/api.ts

---

Read file: packages/client-direct/src/api.ts

---

Cancelled

---

_**User**_

å¦‚æœæˆ‘è¦ä»å¤–éƒ¨å·¥ç¨‹ï¼Œæ¯”å¦‚ç½‘ç«™çš„åç«¯è°ƒç”¨client-direct/src/api.tsï¼Œåˆ›å»ºå’Œç®¡ç†agentï¼Œè¯¥å¦‚ä½•å®ç°

---

_**Assistant**_

å¦‚æœè¦ä»å¤–éƒ¨å·¥ç¨‹è°ƒç”¨ Eliza é¡¹ç›®ä¸­çš„ `client-direct/src/api.ts`ï¼Œä½ æœ‰å‡ ç§å®ç°æ–¹æ¡ˆï¼š

## æ–¹æ¡ˆä¸€ï¼šé€šè¿‡ HTTP API è°ƒç”¨

æœ€ç®€å•çš„æ–¹æ³•æ˜¯å°† Eliza é¡¹ç›®ä½œä¸ºç‹¬ç«‹æœåŠ¡è¿è¡Œï¼Œç„¶åé€šè¿‡ HTTP API è¿›è¡Œè°ƒç”¨ï¼š

1. **å¯åŠ¨ Eliza æœåŠ¡**
   - ç¡®ä¿ Eliza é¡¹ç›®å·²å¯åŠ¨ï¼Œå¹¶ä¸” Express æœåŠ¡å™¨æ­£åœ¨è¿è¡Œ
   - è®°å½• Eliza æœåŠ¡çš„ URLï¼ˆå¦‚ `http://localhost:3000`ï¼‰

2. **ä»å¤–éƒ¨å·¥ç¨‹å‘é€ HTTP è¯·æ±‚**
   ```javascript
   // åœ¨ä½ çš„ç½‘ç«™åç«¯ä¸­
   async function createAgent(agentData) {
     try {
       const response = await fetch('http://eliza-server:3000/agents', {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json',
         },
         body: JSON.stringify(agentData),
       });
       
       if (!response.ok) {
         throw new Error(`HTTP error! status: ${response.status}`);
       }
       
       return await response.json();
     } catch (error) {
       console.error('Error creating agent:', error);
       throw error;
     }
   }
   ```

## æ–¹æ¡ˆäºŒï¼šå°† Eliza ä½œä¸ºä¾èµ–å¼•å…¥

å¦‚æœä½ çš„é¡¹ç›®ä½¿ç”¨ Node.jsï¼Œå¯ä»¥å°† Eliza ä½œä¸ºæ¨¡å—ä¾èµ–ï¼š

1. **å°† Eliza ä½œä¸ºæœ¬åœ°ä¾èµ–**
   - åœ¨ä½ çš„ `package.json` ä¸­æ·»åŠ æœ¬åœ°ä¾èµ–ï¼š
   ```json
   "dependencies": {
     "eliza": "file:../path/to/eliza"
   }
   ```

2. **å¯¼å…¥å¹¶åˆå§‹åŒ– DirectClient**
   ```javascript
   import { DirectClient } from 'eliza/packages/client-direct';
   
   // åˆå§‹åŒ–å®¢æˆ·ç«¯
   const elizaClient = new DirectClient();
   await elizaClient.initialize();
   
   // åˆ›å»ºä»£ç†
   async function createElizaAgent(characterData) {
     return await elizaClient.startAgent(characterData);
   }
   ```

## æ–¹æ¡ˆä¸‰ï¼šç‹¬ç«‹çš„ä»£ç†ç®¡ç†æœåŠ¡

ä½ ä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ä¸­é—´å±‚æœåŠ¡ï¼Œä¸“é—¨è´Ÿè´£ä¸ Eliza é€šä¿¡ï¼š

1. **åˆ›å»ºä»£ç†ç®¡ç†æœåŠ¡**
   - å®ç°ä¸€ä¸ªç‹¬ç«‹çš„æœåŠ¡ï¼Œä¸“é—¨ç”¨äºç®¡ç† Eliza ä»£ç†
   - æä¾›ç®€åŒ–çš„ APIï¼Œä¾›ä½ çš„ä¸»åº”ç”¨è°ƒç”¨
   - å¤„ç†ä¸ Eliza é€šä¿¡çš„æ‰€æœ‰ç»†èŠ‚

2. **ç¤ºä¾‹ä»£ç **
   ```javascript
   // agent-manager.js
   import express from 'express';
   import fetch from 'node-fetch';
   
   const app = express();
   app.use(express.json());
   
   const ELIZA_BASE_URL = 'http://localhost:3000';
   
   // åˆ›å»ºä»£ç†
   app.post('/create-agent', async (req, res) => {
     try {
       const response = await fetch(`${ELIZA_BASE_URL}/agents`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(req.body)
       });
       
       const data = await response.json();
       res.json(data);
     } catch (error) {
       console.error('Error:', error);
       res.status(500).json({ error: 'Failed to create agent' });
     }
   });
   
   // è·å–ä»£ç†åˆ—è¡¨
   app.get('/agents', async (req, res) => {
     try {
       const response = await fetch(`${ELIZA_BASE_URL}/agents`);
       const data = await response.json();
       res.json(data);
     } catch (error) {
       console.error('Error:', error);
       res.status(500).json({ error: 'Failed to fetch agents' });
     }
   });
   
   // æ›´å¤šAPI...
   
   app.listen(4000, () => {
     console.log('Agent Manager service running on port 4000');
   });
   ```

## å®ç°å»ºè®®

1. **é¦–é€‰æ–¹æ¡ˆä¸€**ï¼ˆHTTP APIï¼‰å¦‚æœä½ åªéœ€è¦åŸºæœ¬çš„ä»£ç†ç®¡ç†åŠŸèƒ½
2. **è€ƒè™‘æ–¹æ¡ˆä¸‰**ï¼ˆä¸­é—´å±‚æœåŠ¡ï¼‰å¦‚æœä½ éœ€è¦ï¼š
   - æ·»åŠ é¢å¤–çš„ä¸šåŠ¡é€»è¾‘
   - å®ç°ç¼“å­˜
   - æ·»åŠ é¢å¤–çš„å®‰å…¨å±‚
   - ç®€åŒ–å¯¹å¤–API

3. **å…³é”®APIç«¯ç‚¹**ï¼š
   - `POST /agents` - åˆ›å»ºæ–°ä»£ç†
   - `GET /agents` - è·å–æ‰€æœ‰ä»£ç†åˆ—è¡¨
   - `GET /agents/:id` - è·å–ç‰¹å®šä»£ç†
   - `DELETE /agents/:id` - åˆ é™¤ä»£ç†
   - `POST /agents/:id/set` - æ›´æ–°ä»£ç†é…ç½®
   - æˆ‘ä»¬æ–°å¢çš„æ¨¡æ¿ç®¡ç†APIç«¯ç‚¹

æ— è®ºé€‰æ‹©å“ªç§æ–¹æ¡ˆï¼Œéƒ½å»ºè®®å®ç°é€‚å½“çš„è®¤è¯å’Œæƒé™æ§åˆ¶ï¼Œç¡®ä¿åªæœ‰æˆæƒç”¨æˆ·æ‰èƒ½ç®¡ç†ä»£ç†ã€‚

---

_**User**_

å¦‚æœéœ€è¦æœåŠ¡å¤šä¸ªç”¨æˆ·ï¼Œæ¯ä¸ªç”¨æˆ·éƒ½ä¼šåˆ›å»ºå’Œä½¿ç”¨ï¼ŒåŸºäºå½“å‰elizaçš„æ¶æ„å’Œapiä»€ä¹ˆæ–¹æ¡ˆ

---

_**Assistant**_

è¦æ”¯æŒå¤šç”¨æˆ·ç¯å¢ƒï¼Œæ¯ä¸ªç”¨æˆ·èƒ½å¤Ÿåˆ›å»ºå’Œä½¿ç”¨è‡ªå·±çš„ä»£ç†ï¼ŒåŸºäºå½“å‰Elizaæ¶æ„ï¼Œæˆ‘å»ºè®®é‡‡ç”¨ä»¥ä¸‹æ–¹æ¡ˆï¼š

## å¤šç”¨æˆ·ç¯å¢ƒæ–¹æ¡ˆ

### 1. ä¸­é—´å±‚å¤šç§Ÿæˆ·æœåŠ¡æ¶æ„

åˆ›å»ºä¸€ä¸ªä¸“é—¨çš„ä¸­é—´å±‚æœåŠ¡ï¼Œè´Ÿè´£ï¼š
- ç”¨æˆ·è®¤è¯ä¸æˆæƒ
- ç§Ÿæˆ·éš”ç¦»
- ä»£ç†ç”Ÿå‘½å‘¨æœŸç®¡ç†
- èµ„æºåˆ†é…ä¸é™åˆ¶

```
ç”¨æˆ· ---> å¤šç§Ÿæˆ·APIæœåŠ¡ ---> ElizaæœåŠ¡
           |
           v
        ç”¨æˆ·æ•°æ®åº“
```

### 2. ä¸­é—´å±‚æœåŠ¡å®ç°ç»†èŠ‚

```javascript
import express from 'express';
import jwt from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';
import fetch from 'node-fetch';

const app = express();
app.use(express.json());

// é…ç½®
const ELIZA_BASE_URL = 'http://localhost:3000';
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// ç®€å•ç”¨æˆ·æ•°æ®å­˜å‚¨ï¼ˆå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ•°æ®åº“ï¼‰
const users = new Map();
const userAgents = new Map(); // ç”¨æˆ·ä¸ä»£ç†çš„æ˜ å°„å…³ç³»

// è®¤è¯ä¸­é—´ä»¶
const authenticate = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Authentication required' });

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

// æ³¨å†Œç”¨æˆ·
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  if (!username || !password) {
    return res.status(400).json({ error: 'Username and password required' });
  }

  if (users.has(username)) {
    return res.status(409).json({ error: 'Username already exists' });
  }

  const userId = uuidv4();
  users.set(username, { id: userId, username, password });
  userAgents.set(userId, []);

  const token = jwt.sign({ id: userId, username }, JWT_SECRET, { expiresIn: '24h' });
  res.status(201).json({ token, userId });
});

// ç”¨æˆ·ç™»å½•
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  const user = users.get(username);
  if (!user || user.password !== password) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  const token = jwt.sign({ id: user.id, username }, JWT_SECRET, { expiresIn: '24h' });
  res.json({ token, userId: user.id });
});

// åˆ›å»ºä»£ç†
app.post('/agents', authenticate, async (req, res) => {
  const userId = req.user.id;
  const { name, description, ...characterConfig } = req.body;

  // æ·»åŠ ç”¨æˆ·IDåˆ°è§’è‰²é…ç½®ä¸­ï¼ˆç”¨äºæƒé™æ£€æŸ¥ï¼‰
  const characterData = {
    ...characterConfig,
    name,
    description,
    metadata: {
      ...(characterConfig.metadata || {}),
      ownerId: userId,
      created: new Date().toISOString()
    }
  };

  try {
    // è°ƒç”¨Eliza APIåˆ›å»ºä»£ç†
    const response = await fetch(`${ELIZA_BASE_URL}/agents`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(characterData)
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const agentData = await response.json();
    
    // è®°å½•ç”¨æˆ·ä¸ä»£ç†çš„å…³ç³»
    const userAgentList = userAgents.get(userId) || [];
    userAgentList.push(agentData.id);
    userAgents.set(userId, userAgentList);

    res.status(201).json(agentData);
  } catch (error) {
    console.error('Error creating agent:', error);
    res.status(500).json({ error: 'Failed to create agent' });
  }
});

// è·å–ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨
app.get('/agents', authenticate, async (req, res) => {
  const userId = req.user.id;
  
  try {
    // ä»Elizaè·å–æ‰€æœ‰ä»£ç†
    const response = await fetch(`${ELIZA_BASE_URL}/agents`);
    const { agents } = await response.json();
    
    // è¿‡æ»¤ç”¨æˆ·è‡ªå·±çš„ä»£ç†
    const userAgentIds = userAgents.get(userId) || [];
    const userOwnedAgents = agents.filter(agent => userAgentIds.includes(agent.id));
    
    res.json({ agents: userOwnedAgents });
  } catch (error) {
    console.error('Error fetching agents:', error);
    res.status(500).json({ error: 'Failed to fetch agents' });
  }
});

// è·å–ç‰¹å®šä»£ç†ï¼ˆå¹¶æ£€æŸ¥æ‰€æœ‰æƒï¼‰
app.get('/agents/:agentId', authenticate, async (req, res) => {
  const userId = req.user.id;
  const { agentId } = req.params;
  
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰æ­¤ä»£ç†
  const userAgentIds = userAgents.get(userId) || [];
  if (!userAgentIds.includes(agentId)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  try {
    const response = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}`);
    if (!response.ok) {
      return res.status(response.status).json({ error: 'Agent not found' });
    }
    
    const agentData = await response.json();
    res.json(agentData);
  } catch (error) {
    console.error('Error fetching agent:', error);
    res.status(500).json({ error: 'Failed to fetch agent' });
  }
});

// åˆ é™¤ä»£ç†
app.delete('/agents/:agentId', authenticate, async (req, res) => {
  const userId = req.user.id;
  const { agentId } = req.params;
  
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰æ­¤ä»£ç†
  const userAgentIds = userAgents.get(userId) || [];
  if (!userAgentIds.includes(agentId)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  try {
    const response = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}`, {
      method: 'DELETE'
    });
    
    if (!response.ok) {
      return res.status(response.status).json({ error: 'Failed to delete agent' });
    }
    
    // ä»ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨ä¸­åˆ é™¤
    const updatedAgentIds = userAgentIds.filter(id => id !== agentId);
    userAgents.set(userId, updatedAgentIds);
    
    res.status(204).send();
  } catch (error) {
    console.error('Error deleting agent:', error);
    res.status(500).json({ error: 'Failed to delete agent' });
  }
});

// æ›´å¤šAPIè·¯ç”±...

// æ¨¡æ¿ç›¸å…³API
app.get('/agent-templates', async (req, res) => {
  try {
    const response = await fetch(`${ELIZA_BASE_URL}/agent-templates`);
    const templates = await response.json();
    res.json(templates);
  } catch (error) {
    console.error('Error fetching templates:', error);
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});

app.listen(4000, () => {
  console.log('Multi-tenant Agent Manager running on port 4000');
});
```

### 3. æ‰©å±•å»ºè®®

**æé«˜å®‰å…¨æ€§**ï¼š
- å®ç°æ›´å¼ºçš„å¯†ç ç­–ç•¥ï¼ˆå“ˆå¸Œã€ç›ç­‰ï¼‰
- æ·»åŠ è§’è‰²å’Œæƒé™ç³»ç»Ÿ
- å®ç°é€Ÿç‡é™åˆ¶ï¼Œé˜²æ­¢APIæ»¥ç”¨

**æé«˜å¯æ‰©å±•æ€§**ï¼š
- å°†ç”¨æˆ·æ•°æ®å’Œä»£ç†å…³ç³»å­˜å‚¨åœ¨æ•°æ®åº“ä¸­
- æ·»åŠ ç¼“å­˜æœºåˆ¶å‡å°‘å¯¹Elizaçš„è¯·æ±‚
- å®ç°ä»£ç†å®ä¾‹æ± åŒ–ç®¡ç†

**èµ„æºç®¡ç†**ï¼š
- ä¸ºæ¯ä¸ªç”¨æˆ·è®¾ç½®ä»£ç†æ•°é‡é™åˆ¶
- ç›‘æ§ä»£ç†èµ„æºä½¿ç”¨æƒ…å†µ
- å®ç°èµ„æºåŸºäºé…é¢çš„åˆ†é…æœºåˆ¶

**å¤šå®ä¾‹æ‰©å±•**ï¼š
- å¯¹äºé«˜éœ€æ±‚åœºæ™¯ï¼Œå¯ä»¥ä¸ºä¸åŒç”¨æˆ·ç»„éƒ¨ç½²å¤šä¸ªElizaå®ä¾‹
- å®ç°è´Ÿè½½å‡è¡¡è·¯ç”±è¯·æ±‚åˆ°ä¸åŒå®ä¾‹

### 4. æ•°æ®åº“æ¶æ„ç¤ºä¾‹

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
  id UUID PRIMARY KEY,
  username VARCHAR(100) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  quota_agents INT DEFAULT 5
);

-- ä»£ç†è¡¨
CREATE TABLE agents (
  id UUID PRIMARY KEY,
  eliza_agent_id UUID NOT NULL,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  owner_id UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_used TIMESTAMP,
  is_active BOOLEAN DEFAULT TRUE
);

-- ä¼šè¯è¡¨
CREATE TABLE sessions (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  agent_id UUID REFERENCES agents(id),
  started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  ended_at TIMESTAMP,
  message_count INT DEFAULT 0
);
```

è¿™ç§æ¶æ„èƒ½å¤Ÿæ»¡è¶³å¤šç”¨æˆ·ç¯å¢ƒçš„éœ€æ±‚ï¼ŒåŒæ—¶ä¿æŒä¸ç°æœ‰Eliza APIçš„å…¼å®¹æ€§ï¼Œæœ€å°åŒ–å¯¹Elizaæ ¸å¿ƒåŠŸèƒ½çš„ä¿®æ”¹ã€‚

---

_**User**_

è¿™ç§æƒ…å†µEliza é¡¹ç›®ä½œä¸ºç‹¬ç«‹æœåŠ¡è¿è¡Œå—ï¼Ÿ å¦‚æœå¤šä¸ªç”¨æˆ·ï¼Œæ¯ä¸ªç”¨æˆ·éƒ½å¯åŠ¨å„è‡ªçš„agentï¼Œå¦‚ä½•éƒ¨ç½²

---

_**Assistant**_

æ˜¯çš„ï¼Œåœ¨è¿™ç§å¤šç”¨æˆ·ç¯å¢ƒä¸‹ï¼ŒElizaé¡¹ç›®åº”è¯¥ä½œä¸ºç‹¬ç«‹æœåŠ¡è¿è¡Œã€‚å¯¹äºå¤šç”¨æˆ·ç¯å¢ƒä¸­æ¯ä¸ªç”¨æˆ·å¯åŠ¨è‡ªå·±çš„agentçš„éƒ¨ç½²æ–¹æ¡ˆï¼Œæœ‰å‡ ç§å¯è¡Œçš„æ¶æ„ï¼š

## å¤šç”¨æˆ·éƒ¨ç½²æ–¹æ¡ˆ

### 1. å•å®ä¾‹å…±äº«æ¨¡å¼

**æ¶æ„**:
```
                   +----------------+
                   |                |
ç”¨æˆ·1 ---+         |                |
ç”¨æˆ·2 ---|-- APIæœåŠ¡ ---> Elizaå®ä¾‹ |
ç”¨æˆ·3 ---+         |   (å…±äº«æ¨¡å¼)   |
                   |                |
                   +----------------+
```

**ç‰¹ç‚¹**:
- æ‰€æœ‰ç”¨æˆ·å…±äº«ä¸€ä¸ªElizaå®ä¾‹
- æ‰€æœ‰ä»£ç†åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­è¿è¡Œ
- é€šè¿‡APIæœåŠ¡ç®¡ç†ç”¨æˆ·å’Œä»£ç†çš„æ˜ å°„å…³ç³»

**éƒ¨ç½²æ–¹å¼**:
1. å¯åŠ¨ä¸€ä¸ªä¸­å¤®ElizaæœåŠ¡å®ä¾‹
2. é…ç½®è¶³å¤Ÿçš„ç³»ç»Ÿèµ„æºä»¥æ”¯æŒé¢„æœŸçš„ä»£ç†æ€»é‡
3. æ‰€æœ‰ç”¨æˆ·çš„ä»£ç†éƒ½åœ¨è¿™ä¸€ä¸ªå®ä¾‹ä¸­åˆ›å»ºå’Œç®¡ç†

**ä¼˜åŠ¿**:
- ç®€å•æ˜“ç®¡ç†
- èµ„æºå…±äº«æ•ˆç‡é«˜
- æ˜“äºç›‘æ§å’Œç»´æŠ¤

**å±€é™æ€§**:
- å•ç‚¹æ•…éšœé£é™©
- èµ„æºç«äº‰é—®é¢˜
- æ‰©å±•æ€§æœ‰é™
- ä¸€ä¸ªç”¨æˆ·çš„é«˜èµ„æºä½¿ç”¨å¯èƒ½å½±å“å…¶ä»–ç”¨æˆ·

### 2. å¤šå®ä¾‹éš”ç¦»æ¨¡å¼

**æ¶æ„**:
```
            +----------------+    +----------------+
ç”¨æˆ·1 -----> | APIæœåŠ¡ + Eliza |    |                |
            | å®ä¾‹1          |    |                |
            +----------------+    |                |
                                 |                |
            +----------------+    |                |
ç”¨æˆ·2 -----> | APIæœåŠ¡ + Eliza |---> | æ•°æ®åº“/å­˜å‚¨æœåŠ¡ |
            | å®ä¾‹2          |    |                |
            +----------------+    |                |
                                 |                |
            +----------------+    |                |
ç”¨æˆ·3 -----> | APIæœåŠ¡ + Eliza |    |                |
            | å®ä¾‹3          |    |                |
            +----------------+    +----------------+
```

**ç‰¹ç‚¹**:
- æ¯ä¸ªç”¨æˆ·(æˆ–ç”¨æˆ·ç»„)æœ‰è‡ªå·±çš„Elizaå®ä¾‹
- å®Œå…¨éš”ç¦»çš„èµ„æºå’Œè¿è¡Œç¯å¢ƒ
- ä¸­å¤®æ•°æ®åº“å­˜å‚¨ç”¨æˆ·ä¿¡æ¯å’Œé…ç½®

**éƒ¨ç½²æ–¹å¼**:
1. ä¸ºæ¯ä¸ªç”¨æˆ·(æˆ–æ¯ç»„ç”¨æˆ·)éƒ¨ç½²ç‹¬ç«‹çš„Elizaå®ä¾‹
2. ä½¿ç”¨å®¹å™¨æŠ€æœ¯(å¦‚Docker)æˆ–è™šæ‹Ÿæœºå®ç°éš”ç¦»
3. å®æ–½è‡ªåŠ¨åŒ–éƒ¨ç½²å’Œæ‰©å±•æœºåˆ¶

**ä¼˜åŠ¿**:
- å¼ºéš”ç¦»æ€§ï¼Œç”¨æˆ·é—´ä¸ä¼šç›¸äº’å½±å“
- æŒ‰éœ€æ‰©å±•ï¼Œå¯ä»¥ä¸ºé«˜éœ€æ±‚ç”¨æˆ·åˆ†é…æ›´å¤šèµ„æº
- é«˜å¯ç”¨æ€§ï¼Œå•ä¸ªå®ä¾‹æ•…éšœåªå½±å“ä¸€éƒ¨åˆ†ç”¨æˆ·

**å±€é™æ€§**:
- éƒ¨ç½²å’Œç®¡ç†å¤æ‚åº¦é«˜
- èµ„æºåˆ©ç”¨ç‡å¯èƒ½è¾ƒä½
- éœ€è¦æ›´å¤šçš„åŸºç¡€è®¾æ–½æ”¯æŒ

### 3. æ··åˆå¼¹æ€§æ¨¡å¼ (æ¨è)

**æ¶æ„**:
```
                     +------------------+
                     |                  |
                     | ç”¨æˆ·ç®¡ç†æœåŠ¡      |
                     | (èº«ä»½éªŒè¯/æˆæƒ)   |
                     |                  |
                     +--------+---------+
                              |
           +------------------+-----------------+
           |                  |                 |
+----------v----------+ +-----v------+  +------v-----+
|                     | |            |  |            |
| Elizaå®ä¾‹Pool       | | ä»£ç†ç®¡ç†å™¨  |  | ç›‘æ§æœåŠ¡   |
| (å¼¹æ€§æ‰©å±•)          | |            |  |            |
|                     | |            |  |            |
+---------------------+ +------------+  +------------+
```

**ç‰¹ç‚¹**:
- ç»´æŠ¤ä¸€ä¸ªElizaå®ä¾‹æ± 
- æ ¹æ®è´Ÿè½½å’Œä½¿ç”¨æ¨¡å¼åŠ¨æ€åˆ†é…ä»£ç†åˆ°åˆé€‚çš„å®ä¾‹
- æ™ºèƒ½èµ„æºç®¡ç†å’Œè´Ÿè½½å‡è¡¡

**éƒ¨ç½²æ–¹å¼**:
1. ä½¿ç”¨Kubernetesç®¡ç†Elizaå®ä¾‹çš„å¼¹æ€§ä¼¸ç¼©
2. ä»£ç†ç®¡ç†å™¨ä½œä¸ºä¸­é—´å±‚ï¼Œè´Ÿè´£ä»£ç†çš„åˆ†é…å’Œç®¡ç†
3. å®ç°æ™ºèƒ½è°ƒåº¦ç®—æ³•ä¼˜åŒ–ä»£ç†éƒ¨ç½²

**å…·ä½“å®ç°**:

1. **ç”¨æˆ·ç®¡ç†æœåŠ¡**:
   - å¤„ç†ç”¨æˆ·æ³¨å†Œã€è®¤è¯å’Œæˆæƒ
   - ç»´æŠ¤ç”¨æˆ·ä¸ä»£ç†çš„æ˜ å°„å…³ç³»
   - ç®¡ç†é…é¢å’Œæƒé™

2. **ä»£ç†ç®¡ç†å™¨**:
   - åˆ†æä»£ç†èµ„æºéœ€æ±‚
   - å†³å®šå°†æ–°ä»£ç†éƒ¨ç½²åˆ°å“ªä¸ªElizaå®ä¾‹
   - ç®¡ç†ä»£ç†ç”Ÿå‘½å‘¨æœŸï¼ˆåˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ï¼‰

3. **Elizaå®ä¾‹æ± **:
   - ä½¿ç”¨Kubernetesç®¡ç†å¤šä¸ªEliza Pod
   - æ ¹æ®è´Ÿè½½è‡ªåŠ¨æ‰©ç¼©å®¹
   - é€šè¿‡æŒä¹…åŒ–å­˜å‚¨ç¡®ä¿ä»£ç†æ•°æ®å®‰å…¨æ€§

4. **ç›‘æ§æœåŠ¡**:
   - è·Ÿè¸ªä»£ç†èµ„æºä½¿ç”¨æƒ…å†µ
   - æ£€æµ‹æ€§èƒ½ç“¶é¢ˆ
   - ç”Ÿæˆä½¿ç”¨æŠ¥å‘Šå’Œè­¦æŠ¥

**ä¼˜åŠ¿**:
- çµæ´»æ€§ä¸éš”ç¦»æ€§çš„å¹³è¡¡
- èµ„æºåˆ©ç”¨æ•ˆç‡é«˜
- å¯æ ¹æ®å®é™…éœ€æ±‚åŠ¨æ€æ‰©å±•
- æ•…éšœæ¢å¤èƒ½åŠ›å¼º

**å±€é™æ€§**:
- ç³»ç»Ÿå¤æ‚åº¦è¾ƒé«˜
- éœ€è¦è¾ƒå¤æ‚çš„ç¼–æ’å’Œè°ƒåº¦é€»è¾‘
- éœ€è¦æ›´å¤šçš„å¼€å‘å’Œè¿ç»´æŠ•å…¥

## å…·ä½“éƒ¨ç½²å»ºè®®

### 1. Docker Composeç¤ºä¾‹ï¼ˆå°å‹éƒ¨ç½²ï¼‰

```yaml
version: '3'

services:
  eliza-api:
    image: eliza-api:latest
    ports:
      - "3000:3000"
    volumes:
      - eliza-data:/app/data
    environment:
      - NODE_ENV=production
      - DB_CONNECTION=mongodb://db:27017/eliza
    depends_on:
      - db
    restart: always

  user-service:
    image: eliza-user-service:latest
    ports:
      - "4000:4000"
    environment:
      - ELIZA_API_URL=http://eliza-api:3000
      - JWT_SECRET=your_secret_key
      - DB_CONNECTION=mongodb://db:27017/users
    depends_on:
      - db
      - eliza-api
    restart: always

  db:
    image: mongo:latest
    volumes:
      - mongodb-data:/data/db
    ports:
      - "27017:27017"

volumes:
  eliza-data:
  mongodb-data:
```

### 2. Kuberneteséƒ¨ç½²ï¼ˆå¤§å‹éƒ¨ç½²ï¼‰

**Eliza APIéƒ¨ç½²æ¸…å•**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: eliza-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: eliza-api
  template:
    metadata:
      labels:
        app: eliza-api
    spec:
      containers:
      - name: eliza-api
        image: eliza-api:latest
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        env:
        - name: NODE_ENV
          value: "production"
        - name: DB_CONNECTION
          valueFrom:
            secretKeyRef:
              name: eliza-secrets
              key: db-connection
        ports:
        - containerPort: 3000
        volumeMounts:
        - name: eliza-data
          mountPath: /app/data
      volumes:
      - name: eliza-data
        persistentVolumeClaim:
          claimName: eliza-data-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: eliza-api-service
spec:
  selector:
    app: eliza-api
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
```

**æ°´å¹³è‡ªåŠ¨ç¼©æ”¾**:
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: eliza-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: eliza-api
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

## å®æ–½è·¯çº¿å›¾

1. **ç¬¬ä¸€é˜¶æ®µ**: å•å®ä¾‹å…±äº«æ¨¡å¼
   - ä¸ºå¿«é€ŸéªŒè¯å¤šç”¨æˆ·æ¦‚å¿µæ­å»ºæœ€å°ç³»ç»Ÿ
   - å»ºç«‹ç”¨æˆ·ç®¡ç†å’Œè®¤è¯æœºåˆ¶
   - å®ç°åŸºæœ¬çš„ä»£ç†ç®¡ç†åŠŸèƒ½

2. **ç¬¬äºŒé˜¶æ®µ**: æ‰©å±•è‡³æ··åˆå¼¹æ€§æ¨¡å¼
   - å¼•å…¥ä»£ç†èµ„æºåˆ†æå’Œè°ƒåº¦
   - å®ç°Elizaå®ä¾‹çš„åŠ¨æ€æ‰©å±•
   - å¼€å‘ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ

3. **ç¬¬ä¸‰é˜¶æ®µ**: å®Œå–„å’Œä¼˜åŒ–
   - æé«˜ç³»ç»Ÿå¯é æ€§å’Œå¯ç”¨æ€§
   - ä¼˜åŒ–èµ„æºä½¿ç”¨æ•ˆç‡
   - å¼•å…¥æ›´ç»†ç²’åº¦çš„æƒé™æ§åˆ¶
   - å®Œå–„è®¡è´¹å’Œé…é¢ç®¡ç†

è¿™ç§æ¸è¿›å¼çš„å®æ–½ç­–ç•¥èƒ½å¤Ÿåœ¨ä¸åŒè§„æ¨¡çš„ç”¨æˆ·ç¾¤ä½“ä¸‹ä¿æŒç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯æ‰©å±•æ€§ã€‚

---

_**User**_

å¦‚æœå¤šä¸ªç”¨æˆ·ä½¿ç”¨çš„ä»£ç†é…ç½®ä¸ä¸€æ ·ï¼Œæ¯”å¦‚characterä¸ä¸€æ ·ï¼Œæ˜¯å¦å¯ä»¥å…±äº«ä¸€ä¸ªelizaå®ä¾‹åˆ›å»ºä»£ç†ã€å¯åŠ¨ä»£ç†

---

_**Assistant**_

æ˜¯çš„ï¼Œå¤šä¸ªç”¨æˆ·ä½¿ç”¨ä¸åŒçš„ä»£ç†é…ç½®ï¼ˆåŒ…æ‹¬ä¸åŒçš„characterï¼‰å®Œå…¨å¯ä»¥å…±äº«åŒä¸€ä¸ªElizaå®ä¾‹ã€‚è¿™æ­£æ˜¯Elizaçš„è®¾è®¡ä¼˜åŠ¿ä¹‹ä¸€ã€‚

## å…±äº«Elizaå®ä¾‹çš„å·¥ä½œåŸç†

åœ¨Elizaæ¶æ„ä¸­ï¼Œä¸€ä¸ªå®ä¾‹å¯ä»¥ç®¡ç†å¤šä¸ªä¸åŒé…ç½®çš„ä»£ç†ï¼Œæ¯ä¸ªä»£ç†éƒ½æœ‰è‡ªå·±çš„ï¼š

1. **ç‹¬ç«‹é…ç½®** - åŒ…æ‹¬characterå®šä¹‰ã€æ¨¡å‹å‚æ•°ç­‰
2. **éš”ç¦»ä¸Šä¸‹æ–‡** - æ¯ä¸ªä»£ç†æœ‰è‡ªå·±çš„ä¼šè¯å’Œè®°å¿†ç©ºé—´
3. **èµ„æºåˆ†é…** - åœ¨åŒä¸€å®ä¾‹ä¸­è¿è¡Œä½†èµ„æºç›¸å¯¹ç‹¬ç«‹

## å…³é”®è€ƒè™‘å› ç´ 

### 1. ä»£ç†åˆ›å»ºè¿‡ç¨‹

å½“ç”¨æˆ·åˆ›å»ºæ–°ä»£ç†æ—¶ï¼Œå‘ç”Ÿä»¥ä¸‹è¿‡ç¨‹ï¼š

```
ç”¨æˆ· ---> APIè¯·æ±‚ ---> Elizaå®ä¾‹ ---> åŠ è½½ç‰¹å®šcharacteré…ç½® 
                                  ---> åˆå§‹åŒ–ä»£ç†ä¸Šä¸‹æ–‡
                                  ---> åˆ†é…å”¯ä¸€ID
                                  ---> è¿”å›ä»£ç†ä¿¡æ¯
```

æ¯ä¸ªä»£ç†éƒ½é€šè¿‡å”¯ä¸€IDåŒºåˆ†ï¼Œè¿™ä½¿å¾—å¤šä¸ªä¸åŒé…ç½®çš„ä»£ç†å¯ä»¥åœ¨åŒä¸€ä¸ªElizaå®ä¾‹ä¸­å…±å­˜ã€‚

### 2. èµ„æºå…±äº«ä¸é™åˆ¶

å…±äº«å®ä¾‹çš„ä¸»è¦è€ƒè™‘å› ç´ æ˜¯èµ„æºç®¡ç†ï¼š

- **å†…å­˜ä½¿ç”¨** - æ¯ä¸ªä»£ç†ä¼šå ç”¨ä¸€å®šå†…å­˜ç©ºé—´ï¼ˆå°¤å…¶æ˜¯åŠ è½½å¤§å‹æ¨¡å‹æ—¶ï¼‰
- **CPUåˆ©ç”¨** - æ´»è·ƒçš„ä»£ç†ä¼šæ¶ˆè€—è®¡ç®—èµ„æº
- **ç½‘ç»œå¸¦å®½** - ä¸æ¨¡å‹APIé€šä¿¡éœ€è¦å¸¦å®½

éœ€è¦æ ¹æ®é¢„æœŸçš„å¹¶å‘ä»£ç†æ•°é‡å’Œæ¯ä¸ªä»£ç†çš„èµ„æºéœ€æ±‚æ¥è§„åˆ’Elizaå®ä¾‹çš„å¤§å°ã€‚

## å®æ–½å»ºè®®

### 1. åŸºäºç”¨æˆ·ç®¡ç†çš„è®¿é—®æ§åˆ¶

```javascript
// åœ¨APIæœåŠ¡ä¸­å®ç°ç”¨æˆ·åˆ°ä»£ç†çš„æ˜ å°„
const userAgentMap = new Map();

// åˆ›å»ºä»£ç†æ—¶
app.post('/agents', authenticate, async (req, res) => {
  const userId = req.user.id;
  const characterConfig = req.body;
  
  try {
    // è°ƒç”¨Eliza APIåˆ›å»ºä»£ç†
    const response = await fetch(`${ELIZA_BASE_URL}/agents`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(characterConfig)
    });
    
    const agent = await response.json();
    
    // è®°å½•ç”¨æˆ·ä¸ä»£ç†çš„å…³ç³»
    if (!userAgentMap.has(userId)) {
      userAgentMap.set(userId, []);
    }
    userAgentMap.get(userId).push(agent.id);
    
    res.json(agent);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create agent' });
  }
});

// ä½¿ç”¨ä»£ç†æ—¶éªŒè¯æ‰€æœ‰æƒ
app.post('/agents/:agentId/message', authenticate, async (req, res) => {
  const userId = req.user.id;
  const { agentId } = req.params;
  
  // éªŒè¯ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰æ­¤ä»£ç†
  const userAgents = userAgentMap.get(userId) || [];
  if (!userAgents.includes(agentId)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  // ç»§ç»­å¤„ç†æ¶ˆæ¯...
});
```

### 2. èµ„æºç®¡ç†ä¸é™åˆ¶

```javascript
// åœ¨ä¸­é—´å±‚è®¾ç½®ç”¨æˆ·é…é¢
const userQuotas = new Map();

// è®¾ç½®é»˜è®¤é…é¢
app.post('/register', async (req, res) => {
  // ... ç”¨æˆ·æ³¨å†Œé€»è¾‘ ...
  
  // è®¾ç½®é»˜è®¤é…é¢
  userQuotas.set(userId, {
    maxAgents: 5,          // æœ€å¤§ä»£ç†æ•°
    concurrentAgents: 2,   // åŒæ—¶æ´»è·ƒçš„ä»£ç†æ•°
    messagesPerDay: 100    // æ¯æ—¥æ¶ˆæ¯é…é¢
  });
  
  // ... è¿”å›æ³¨å†Œç»“æœ ...
});

// æ£€æŸ¥é…é¢
app.post('/agents', authenticate, async (req, res) => {
  const userId = req.user.id;
  
  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¶…è¿‡ä»£ç†æ•°é‡é…é¢
  const userAgents = userAgentMap.get(userId) || [];
  const quota = userQuotas.get(userId);
  
  if (userAgents.length >= quota.maxAgents) {
    return res.status(403).json({ 
      error: 'Agent quota exceeded',
      current: userAgents.length,
      limit: quota.maxAgents
    });
  }
  
  // ç»§ç»­åˆ›å»ºä»£ç†...
});
```

### 3. ç³»ç»Ÿç›‘æ§ä¸å‘Šè­¦

é‡è¦çš„æ˜¯å®æ–½é€‚å½“çš„ç›‘æ§ï¼Œä»¥ç¡®ä¿å…±äº«å®ä¾‹ä¸ä¼šè¶…è´Ÿè·ï¼š

```javascript
// å®šæœŸæ£€æŸ¥ç³»ç»Ÿèµ„æº
setInterval(async () => {
  try {
    // è·å–Elizaå®ä¾‹çŠ¶æ€
    const response = await fetch(`${ELIZA_BASE_URL}/status`);
    const status = await response.json();
    
    // æ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ
    if (status.memoryUsage > 85) {
      // è§¦å‘å†…å­˜ä½¿ç”¨è­¦æŠ¥
      alertAdmins('HIGH_MEMORY_USAGE', status.memoryUsage);
    }
    
    if (status.activeAgents > 50) {
      // è§¦å‘ä»£ç†æ•°é‡è­¦æŠ¥
      alertAdmins('HIGH_AGENT_COUNT', status.activeAgents);
    }
  } catch (error) {
    console.error('Monitoring error:', error);
  }
}, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
```

## æ‰©å±•åˆ°å¤šå®ä¾‹

å½“å•ä¸ªElizaå®ä¾‹è¾¾åˆ°èµ„æºé™åˆ¶æ—¶ï¼Œå¯ä»¥å¹³æ»‘æ‰©å±•åˆ°å¤šå®ä¾‹æ¨¡å¼ï¼š

```
ç”¨æˆ·1 ---+         +------------+
ç”¨æˆ·2 ---|--> APIæœåŠ¡ --> Elizaå®ä¾‹1 |
ç”¨æˆ·3 ---+    |    +------------+
              |
ç”¨æˆ·4 ---+    |    +------------+
ç”¨æˆ·5 ---|--> |--> Elizaå®ä¾‹2 |
ç”¨æˆ·6 ---+    |    +------------+
              |
              |    +------------+
              +--> Elizaå®ä¾‹3 |
                   +------------+
```

ä¸­é—´å±‚APIæœåŠ¡å¯ä»¥å®ç°æ™ºèƒ½è·¯ç”±ï¼ŒåŸºäºä»¥ä¸‹å› ç´ å°†è¯·æ±‚è·¯ç”±åˆ°åˆé€‚çš„Elizaå®ä¾‹ï¼š
1. è´Ÿè½½å‡è¡¡
2. ä»£ç†æ‰€åœ¨ä½ç½®
3. å®ä¾‹èµ„æºä½¿ç”¨æƒ…å†µ

## ç»“è®º

Elizaå®Œå…¨æ”¯æŒåœ¨å•ä¸ªå®ä¾‹ä¸­è¿è¡Œå…·æœ‰ä¸åŒé…ç½®çš„å¤šä¸ªä»£ç†ã€‚è¿™ç§æ¶æ„ä¸ºå¤šç”¨æˆ·ç¯å¢ƒæä¾›äº†è‰¯å¥½çš„èµ·ç‚¹ï¼Œèƒ½å¤Ÿåœ¨èµ„æºæ•ˆç‡å’Œæ“ä½œç®€ä¾¿æ€§ä¹‹é—´å–å¾—å¹³è¡¡ã€‚éšç€ç”¨æˆ·å’Œä»£ç†æ•°é‡çš„å¢é•¿ï¼Œå¯ä»¥é€æ­¥æ‰©å±•åˆ°æ›´å¤æ‚çš„å¤šå®ä¾‹æ¶æ„ã€‚

å…³é”®æ˜¯å®ç°é€‚å½“çš„ç”¨æˆ·ç®¡ç†ã€è®¿é—®æ§åˆ¶å’Œèµ„æºç›‘æ§ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œå®‰å…¨æ€§ã€‚

---

_**User**_

åœ¨elizaå®ä¾‹è¿è¡Œä¸­æ˜¯å¦å¯ä»¥åˆ›å»ºå¹¶å¯åŠ¨æ–°çš„ä»£ç†ï¼Ÿ

---

_**Assistant**_

æ˜¯çš„ï¼Œåœ¨Elizaå®ä¾‹è¿è¡Œä¸­å®Œå…¨å¯ä»¥åˆ›å»ºå¹¶å¯åŠ¨æ–°çš„ä»£ç†ï¼Œè¿™æ˜¯Elizaçš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ã€‚

## ElizaåŠ¨æ€ä»£ç†åˆ›å»ºæœºåˆ¶

Elizaè¢«è®¾è®¡ä¸ºä¸€ä¸ªå¯ä»¥åŠ¨æ€ç®¡ç†å¤šä¸ªä»£ç†çš„ç³»ç»Ÿã€‚å…¶æ¶æ„å…è®¸åœ¨ä¸é‡å¯æ•´ä¸ªElizaæœåŠ¡çš„æƒ…å†µä¸‹ï¼ŒåŠ¨æ€åˆ›å»ºã€å¯åŠ¨ã€åœæ­¢å’Œåˆ é™¤ä»£ç†ã€‚

### å·¥ä½œæµç¨‹

1. **åˆ›å»ºä»£ç†**: é€šè¿‡APIè¯·æ±‚ï¼Œå‘è¿è¡Œä¸­çš„Elizaå®ä¾‹å‘é€åˆ›å»ºä»£ç†çš„è¯·æ±‚
2. **åŠ è½½é…ç½®**: ElizaåŠ è½½æŒ‡å®šçš„characteré…ç½®å’Œæ¨¡å‹è®¾ç½®
3. **åˆå§‹åŒ–ä¸Šä¸‹æ–‡**: ä¸ºæ–°ä»£ç†åˆ›å»ºä¸“å±çš„å†…å­˜ç©ºé—´å’Œä¼šè¯ä¸Šä¸‹æ–‡
4. **å¯åŠ¨ä»£ç†**: åˆ†é…èµ„æºå¹¶ä½¿ä»£ç†å¤„äºå¯ç”¨çŠ¶æ€
5. **è¿”å›ID**: è¿”å›å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œç”¨äºåç»­å¯¹è¯¥ä»£ç†çš„æ“ä½œ

### å®é™…ç¤ºä¾‹

ä»¥ä¸‹æ˜¯é€šè¿‡APIåœ¨è¿è¡Œä¸­çš„Elizaå®ä¾‹åˆ›å»ºæ–°ä»£ç†çš„ç¤ºä¾‹ï¼š

```javascript
// å‘å·²è¿è¡Œçš„Elizaå®ä¾‹åˆ›å»ºæ–°ä»£ç†
async function createNewAgent(characterConfig) {
  try {
    const response = await fetch('http://eliza-server:3000/agents', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(characterConfig),
    });
    
    if (!response.ok) {
      throw new Error(`Failed to create agent: ${response.statusText}`);
    }
    
    const agent = await response.json();
    console.log(`New agent created with ID: ${agent.id}`);
    return agent;
  } catch (error) {
    console.error('Error creating agent:', error);
    throw error;
  }
}

// ç¤ºä¾‹characteré…ç½®
const characterConfig = {
  name: "å®¢æœåŠ©æ‰‹",
  username: "support_assistant",
  bio: "æˆ‘æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å®¢æœåŠ©æ‰‹ï¼Œå¯ä»¥å¸®åŠ©è§£å†³äº§å“ç›¸å…³é—®é¢˜ã€‚",
  lore: [
    "æˆ‘æ“…é•¿è€å¿ƒè§£ç­”å®¢æˆ·é—®é¢˜",
    "æˆ‘çŸ¥é“å¦‚ä½•å¤„ç†å¤æ‚çš„å®¢æœæƒ…å¢ƒ"
  ],
  modelProvider: "openai",
  system: "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å®¢æœåŠ©æ‰‹ï¼Œæ€»æ˜¯ç¤¼è²Œåœ°å›ç­”ç”¨æˆ·é—®é¢˜ã€‚"
};

// è°ƒç”¨å‡½æ•°åˆ›å»ºæ–°ä»£ç†
createNewAgent(characterConfig)
  .then(agent => {
    console.log('Agent ready for use:', agent);
  })
  .catch(error => {
    console.error('Failed to create agent:', error);
  });
```

## æŠ€æœ¯å®ç°ç»†èŠ‚

ä»Elizaçš„ä»£ç å®ç°æ¥çœ‹ï¼š

1. **DirectClientç±»**ï¼šåœ¨`packages/client-direct/src/index.ts`ä¸­ï¼ŒDirectClientç±»ç»´æŠ¤äº†ä¸€ä¸ªä»£ç†æ˜ å°„(`agents` Map)ï¼Œå¯ä»¥åŠ¨æ€æ·»åŠ å’Œç§»é™¤ä»£ç†

2. **startAgentæ–¹æ³•**ï¼šæ­¤æ–¹æ³•è´Ÿè´£ä»characteré…ç½®åˆ›å»ºæ–°çš„ä»£ç†å®ä¾‹å¹¶å°†å…¶æ·»åŠ åˆ°è¿è¡Œä¸­çš„ç³»ç»Ÿ

3. **ä»£ç†æ³¨å†Œæœºåˆ¶**ï¼šæ¯ä¸ªæ–°åˆ›å»ºçš„ä»£ç†éƒ½ä¼šåœ¨Elizaå®ä¾‹ä¸­æ³¨å†Œï¼Œä½¿å…¶å¯é€šè¿‡APIè®¿é—®

## ä½¿ç”¨åœºæ™¯ç¤ºä¾‹

### åœºæ™¯1: ç”¨æˆ·åˆ›å»ºè‡ªå®šä¹‰ä»£ç†

ç”¨æˆ·å¯ä»¥é€šè¿‡ç•Œé¢è®¾è®¡è‡ªå·±çš„ä»£ç†è§’è‰²ï¼Œç³»ç»Ÿè°ƒç”¨Eliza APIåˆ›å»ºæ–°ä»£ç†ï¼š

```javascript
// å‰ç«¯ç•Œé¢æ”¶é›†ç”¨æˆ·è¾“å…¥
const userDefinedAgent = {
  name: document.getElementById('agent-name').value,
  bio: document.getElementById('agent-bio').value,
  modelProvider: document.getElementById('model-provider').value,
  // ... å…¶ä»–é…ç½®
};

// è°ƒç”¨APIåˆ›å»ºä»£ç†
fetch('/api/agents', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify(userDefinedAgent)
})
.then(response => response.json())
.then(agent => {
  showSuccess(`æˆåŠŸåˆ›å»ºä»£ç†: ${agent.name}`);
  loadAgentInterface(agent.id);
})
.catch(error => showError('åˆ›å»ºä»£ç†å¤±è´¥', error));
```

### åœºæ™¯2: ç³»ç»Ÿæ ¹æ®éœ€æ±‚è‡ªåŠ¨æ‰©å±•ä»£ç†

ç³»ç»Ÿå¯ä»¥æ ¹æ®å·¥ä½œè´Ÿè½½æˆ–ç‰¹å®šäº‹ä»¶è‡ªåŠ¨åˆ›å»ºæ–°ä»£ç†ï¼š

```javascript
// å®¢æœç³»ç»Ÿä¾‹å­ï¼šå½“ç­‰å¾…é˜Ÿåˆ—è¶…è¿‡é˜ˆå€¼æ—¶è‡ªåŠ¨åˆ›å»ºæ–°å®¢æœä»£ç†
async function monitorAndScale() {
  const waitingCustomers = await getWaitingCustomersCount();
  const activeAgents = await getActiveAgentsCount();
  
  if (waitingCustomers > activeAgents * 3) {
    // éœ€è¦æ›´å¤šå®¢æœä»£ç†
    const newAgent = await createNewAgent(customerSupportTemplate);
    await assignToQueue(newAgent.id);
    notifyAdmin(`å·²è‡ªåŠ¨åˆ›å»ºæ–°å®¢æœä»£ç†: ${newAgent.id}`);
  }
}

// å®šæœŸæ£€æŸ¥å¹¶æ‰©å±•
setInterval(monitorAndScale, 60000);
```

## æœ€ä½³å®è·µ

1. **å¼‚æ­¥å¤„ç†**: åˆ›å»ºä»£ç†æ—¶ä½¿ç”¨å¼‚æ­¥æ¨¡å¼ï¼Œé¿å…é˜»å¡ä¸»æµç¨‹

2. **é”™è¯¯å¤„ç†**: å®ç°å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œåº”å¯¹åˆ›å»ºå¤±è´¥æƒ…å†µ

3. **èµ„æºç›‘æ§**: åœ¨åˆ›å»ºæ–°ä»£ç†å‰æ£€æŸ¥ç³»ç»Ÿèµ„æºï¼Œç¡®ä¿æœ‰è¶³å¤Ÿå®¹é‡

4. **é…é¢ç®¡ç†**: å®æ–½ç”¨æˆ·é…é¢ï¼Œé˜²æ­¢èµ„æºè¢«å°‘æ•°ç”¨æˆ·å ç”¨

5. **ä¼˜é›…é™çº§**: å½“ç³»ç»Ÿæ¥è¿‘å®¹é‡ä¸Šé™æ—¶ï¼Œå®æ–½æ’é˜Ÿæˆ–é™çº§ç­–ç•¥

æ€»ç»“æ¥è¯´ï¼ŒElizaç³»ç»Ÿå®Œå…¨æ”¯æŒåœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ›å»ºå’Œå¯åŠ¨æ–°ä»£ç†ï¼Œè¿™æ˜¯å…¶ä½œä¸ºå¤šä»£ç†å¹³å°çš„æ ¸å¿ƒç‰¹æ€§ã€‚è¿™ä½¿å¾—å®ƒéå¸¸é€‚åˆå¤šç”¨æˆ·ç¯å¢ƒå’Œéœ€è¦åŠ¨æ€æ‰©å±•ä»£ç†çš„åº”ç”¨åœºæ™¯ã€‚

---

_**User**_

ç»™å‡ºåœ¨ç½‘ç«™å¹³å°åˆ›å»ºå’Œç®¡ç†ä»£ç†çš„ä»£ç ï¼Œé‡‡ç”¨APIä¸­é—´æœåŠ¡æ··åˆå¼¹æ€§æ¨¡å¼ï¼Œ
å‚è€ƒappSlice.jsxå¤ç”¨ç”¨æˆ·ä¿¡æ¯

---

_**Assistant**_

æˆ‘å°†ä¸ºæ‚¨æä¾›åœ¨ç½‘ç«™å¹³å°åˆ›å»ºå’Œç®¡ç†ä»£ç†çš„ä»£ç å®ç°ï¼Œé‡‡ç”¨APIä¸­é—´æœåŠ¡æ··åˆå¼¹æ€§æ¨¡å¼ï¼Œå¹¶å¤ç”¨`appSlice.jsx`ä¸­çš„ç”¨æˆ·ä¿¡æ¯ã€‚æˆ‘ä»¬éœ€è¦åˆ›å»ºä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š

1. Redux Slice ç”¨äºç®¡ç†ä»£ç†çŠ¶æ€
2. API æœåŠ¡ç”¨äºä¸Elizaé€šä¿¡
3. ä¸­é—´å±‚æœåŠ¡æ¥å£
4. ä»£ç†ç®¡ç†ç»„ä»¶

## 1. åˆ›å»ºä»£ç†ç®¡ç†çš„Redux Slice

```javascript
// src/components/redux/agentSlice.jsx
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import agentService from '../../services/agentService';

// åˆ›å»ºä»£ç†
export const createAgent = createAsyncThunk(
  'agents/create',
  async (agentData, { rejectWithValue }) => {
    try {
      const response = await agentService.createAgent(agentData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// è·å–ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨
export const fetchUserAgents = createAsyncThunk(
  'agents/fetchUserAgents',
  async (_, { rejectWithValue }) => {
    try {
      const response = await agentService.getUserAgents();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// åˆ é™¤ä»£ç†
export const deleteAgent = createAsyncThunk(
  'agents/delete',
  async (agentId, { rejectWithValue }) => {
    try {
      await agentService.deleteAgent(agentId);
      return agentId;
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// å¯åŠ¨ä»£ç†
export const startAgent = createAsyncThunk(
  'agents/start',
  async (agentId, { rejectWithValue }) => {
    try {
      const response = await agentService.startAgent(agentId);
      return { agentId, status: response.data };
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// åœæ­¢ä»£ç†
export const stopAgent = createAsyncThunk(
  'agents/stop',
  async (agentId, { rejectWithValue }) => {
    try {
      const response = await agentService.stopAgent(agentId);
      return { agentId, status: response.data };
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// è·å–æ¨¡æ¿åˆ—è¡¨
export const fetchTemplates = createAsyncThunk(
  'agents/fetchTemplates',
  async (_, { rejectWithValue }) => {
    try {
      const response = await agentService.getTemplates();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

// ä»æ¨¡æ¿åˆ›å»ºä»£ç†
export const createAgentFromTemplate = createAsyncThunk(
  'agents/createFromTemplate',
  async ({templateId, customizations}, { rejectWithValue }) => {
    try {
      const response = await agentService.createAgentFromTemplate(templateId, customizations);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response?.data || error.message);
    }
  }
);

const initialState = {
  agents: [],
  templates: [],
  selectedAgent: null,
  loading: false,
  error: null,
  userQuota: {
    used: 0,
    limit: 5,
    remaining: 5
  }
};

const agentSlice = createSlice({
  name: "agents",
  initialState,
  reducers: {
    setSelectedAgent: (state, action) => {
      state.selectedAgent = action.payload;
    },
    clearAgentError: (state) => {
      state.error = null;
    },
    updateAgentStatus: (state, action) => {
      const { agentId, status } = action.payload;
      const agent = state.agents.find(a => a.id === agentId);
      if (agent) {
        agent.status = status;
      }
    }
  },
  extraReducers: (builder) => {
    builder
      // åˆ›å»ºä»£ç†
      .addCase(createAgent.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createAgent.fulfilled, (state, action) => {
        state.loading = false;
        state.agents.push(action.payload);
        state.userQuota.used += 1;
        state.userQuota.remaining = Math.max(0, state.userQuota.limit - state.userQuota.used);
      })
      .addCase(createAgent.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "åˆ›å»ºä»£ç†å¤±è´¥";
      })
      
      // è·å–ç”¨æˆ·ä»£ç†
      .addCase(fetchUserAgents.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUserAgents.fulfilled, (state, action) => {
        state.loading = false;
        state.agents = action.payload.agents || [];
        if (action.payload.quota) {
          state.userQuota = action.payload.quota;
        } else {
          state.userQuota.used = state.agents.length;
          state.userQuota.remaining = Math.max(0, state.userQuota.limit - state.userQuota.used);
        }
      })
      .addCase(fetchUserAgents.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "è·å–ä»£ç†å¤±è´¥";
      })
      
      // åˆ é™¤ä»£ç†
      .addCase(deleteAgent.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteAgent.fulfilled, (state, action) => {
        state.loading = false;
        state.agents = state.agents.filter(agent => agent.id !== action.payload);
        state.userQuota.used = Math.max(0, state.userQuota.used - 1);
        state.userQuota.remaining = Math.max(0, state.userQuota.limit - state.userQuota.used);
        if (state.selectedAgent && state.selectedAgent.id === action.payload) {
          state.selectedAgent = null;
        }
      })
      .addCase(deleteAgent.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "åˆ é™¤ä»£ç†å¤±è´¥";
      })
      
      // å¯åŠ¨ä»£ç†
      .addCase(startAgent.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(startAgent.fulfilled, (state, action) => {
        state.loading = false;
        const agent = state.agents.find(a => a.id === action.payload.agentId);
        if (agent) {
          agent.status = 'running';
        }
      })
      .addCase(startAgent.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "å¯åŠ¨ä»£ç†å¤±è´¥";
      })
      
      // åœæ­¢ä»£ç†
      .addCase(stopAgent.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(stopAgent.fulfilled, (state, action) => {
        state.loading = false;
        const agent = state.agents.find(a => a.id === action.payload.agentId);
        if (agent) {
          agent.status = 'stopped';
        }
      })
      .addCase(stopAgent.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "åœæ­¢ä»£ç†å¤±è´¥";
      })
      
      // è·å–æ¨¡æ¿
      .addCase(fetchTemplates.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTemplates.fulfilled, (state, action) => {
        state.loading = false;
        state.templates = action.payload.templates || [];
      })
      .addCase(fetchTemplates.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "è·å–æ¨¡æ¿å¤±è´¥";
      })
      
      // ä»æ¨¡æ¿åˆ›å»ºä»£ç†
      .addCase(createAgentFromTemplate.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createAgentFromTemplate.fulfilled, (state, action) => {
        state.loading = false;
        state.agents.push(action.payload);
        state.userQuota.used += 1;
        state.userQuota.remaining = Math.max(0, state.userQuota.limit - state.userQuota.used);
      })
      .addCase(createAgentFromTemplate.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || "ä»æ¨¡æ¿åˆ›å»ºä»£ç†å¤±è´¥";
      });
  }
});

export const { 
  setSelectedAgent, 
  clearAgentError,
  updateAgentStatus
} = agentSlice.actions;

export default agentSlice.reducer;
```

## 2. åˆ›å»ºä»£ç†æœåŠ¡å±‚

```javascript
// src/services/agentService.js
import axios from 'axios';
import { getAuthHeader } from './authService';

// APIä¸­é—´å±‚æœåŠ¡çš„åŸºç¡€URL
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:4000';

// åˆ›å»ºaxioså®ä¾‹
const apiClient = axios.create({
  baseURL: API_URL,
  timeout: 30000, // 30ç§’è¶…æ—¶
  headers: {
    'Content-Type': 'application/json'
  }
});

// è¯·æ±‚æ‹¦æˆªå™¨æ·»åŠ è®¤è¯token
apiClient.interceptors.request.use(
  config => {
    const headers = getAuthHeader();
    if (headers.Authorization) {
      config.headers.Authorization = headers.Authorization;
    }
    return config;
  },
  error => Promise.reject(error)
);

const agentService = {
  // è·å–ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨
  getUserAgents: async () => {
    return await apiClient.get('/agents');
  },
  
  // è·å–ç‰¹å®šä»£ç†è¯¦æƒ…
  getAgent: async (agentId) => {
    return await apiClient.get(`/agents/${agentId}`);
  },
  
  // åˆ›å»ºæ–°ä»£ç†
  createAgent: async (agentData) => {
    return await apiClient.post('/agents', agentData);
  },
  
  // æ›´æ–°ä»£ç†
  updateAgent: async (agentId, agentData) => {
    return await apiClient.put(`/agents/${agentId}`, agentData);
  },
  
  // åˆ é™¤ä»£ç†
  deleteAgent: async (agentId) => {
    return await apiClient.delete(`/agents/${agentId}`);
  },
  
  // å¯åŠ¨ä»£ç†
  startAgent: async (agentId) => {
    return await apiClient.post(`/agents/${agentId}/start`);
  },
  
  // åœæ­¢ä»£ç†
  stopAgent: async (agentId) => {
    return await apiClient.post(`/agents/${agentId}/stop`);
  },
  
  // è·å–ä»£ç†çŠ¶æ€
  getAgentStatus: async (agentId) => {
    return await apiClient.get(`/agents/${agentId}/status`);
  },
  
  // å‘é€æ¶ˆæ¯ç»™ä»£ç†
  sendMessage: async (agentId, message, file = null) => {
    const formData = new FormData();
    formData.append('text', message);
    if (file) {
      formData.append('file', file);
    }
    
    return await apiClient.post(`/agents/${agentId}/message`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });
  },
  
  // è·å–æ¨¡æ¿åˆ—è¡¨
  getTemplates: async () => {
    return await apiClient.get('/agent-templates');
  },
  
  // è·å–ç‰¹å®šæ¨¡æ¿
  getTemplate: async (templateId) => {
    return await apiClient.get(`/agent-templates/${templateId}`);
  },
  
  // ä»æ¨¡æ¿åˆ›å»ºä»£ç†
  createAgentFromTemplate: async (templateId, customizations) => {
    return await apiClient.post(`/agent-templates/${templateId}/create`, customizations);
  },
  
  // è·å–ä»£ç†æ‰€æœ‰æƒä¿¡æ¯
  getUserQuota: async () => {
    return await apiClient.get('/user/agent-quota');
  },
  
  // ä¸Šä¼ çŸ¥è¯†åˆ°ä»£ç†
  uploadKnowledge: async (agentId, file, isShared = false) => {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('isShared', isShared.toString());
    
    return await apiClient.post(`/agents/${agentId}/knowledge`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });
  },
  
  // è·å–ä»£ç†çŸ¥è¯†åº“
  getAgentKnowledge: async (agentId) => {
    return await apiClient.get(`/agents/${agentId}/knowledge`);
  },
  
  // åˆ é™¤çŸ¥è¯†é¡¹
  deleteKnowledge: async (agentId, knowledgeId) => {
    return await apiClient.delete(`/agents/${agentId}/knowledge/${knowledgeId}`);
  }
};

export default agentService;
```

## 3. ä¸­é—´å±‚æœåŠ¡å™¨APIæ¥å£

```javascript
// server/agentMiddlewareService.js
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import jwt from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';
import fetch from 'node-fetch';
import multer from 'multer';
import path from 'path';
import { Pool } from 'pg';

// æ•°æ®åº“é…ç½®
const pool = new Pool({
  user: process.env.DB_USER || "postgres",
  host: process.env.DB_HOST || "localhost",
  database: process.env.DB_NAME || "notesdb",
  password: process.env.DB_PASSWORD || "235711",
  port: process.env.DB_PORT || 5432,
});

// åˆ›å»ºå¿…è¦çš„è¡¨
const initDatabase = async () => {
  try {
    // ç”¨æˆ·ä»£ç†è¡¨
    await pool.query(`
      CREATE TABLE IF NOT EXISTS user_agents (
        id SERIAL PRIMARY KEY,
        user_id TEXT NOT NULL,
        agent_id TEXT NOT NULL,
        name TEXT NOT NULL,
        description TEXT,
        created_at TIMESTAMP DEFAULT NOW(),
        last_used TIMESTAMP DEFAULT NOW(),
        UNIQUE(user_id, agent_id)
      );
    `);
    
    // ç”¨æˆ·é…é¢è¡¨
    await pool.query(`
      CREATE TABLE IF NOT EXISTS user_quotas (
        user_id TEXT PRIMARY KEY,
        max_agents INTEGER DEFAULT 5,
        current_agents INTEGER DEFAULT 0,
        last_updated TIMESTAMP DEFAULT NOW()
      );
    `);
    
    console.log("Database tables initialized");
  } catch (error) {
    console.error("Database initialization error:", error);
  }
};

// é…ç½®
const ELIZA_BASE_URL = process.env.ELIZA_API_URL || 'http://localhost:3000';
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const PORT = process.env.PORT || 4000;

const app = express();

// ä¸­é—´ä»¶
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// æ–‡ä»¶ä¸Šä¼ é…ç½®
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});
const upload = multer({ storage });

// è®¤è¯ä¸­é—´ä»¶
const authenticate = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'è®¤è¯ä»¤ç‰Œç¼ºå¤±' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'æ— æ•ˆçš„è®¤è¯ä»¤ç‰Œ' });
  }
};

// åˆå§‹åŒ–æ•°æ®åº“
initDatabase();

// ç”¨æˆ·ä»£ç†å…³ç³»ç®¡ç†
const userAgentManager = {
  // è·å–ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨
  async getUserAgents(userId) {
    try {
      const result = await pool.query(
        `SELECT * FROM user_agents WHERE user_id = $1 ORDER BY created_at DESC`,
        [userId]
      );
      return result.rows;
    } catch (error) {
      console.error("Error getting user agents:", error);
      throw error;
    }
  },
  
  // æ·»åŠ ä»£ç†åˆ°ç”¨æˆ·
  async addAgentToUser(userId, agentId, name, description) {
    try {
      await pool.query(
        `INSERT INTO user_agents (user_id, agent_id, name, description) 
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (user_id, agent_id) 
         DO UPDATE SET name = $3, description = $4, last_used = NOW()`,
        [userId, agentId, name, description]
      );
      
      // æ›´æ–°ç”¨æˆ·é…é¢
      await pool.query(
        `INSERT INTO user_quotas (user_id, current_agents)
         VALUES ($1, 1)
         ON CONFLICT (user_id)
         DO UPDATE SET current_agents = user_quotas.current_agents + 1, last_updated = NOW()`,
        [userId]
      );
    } catch (error) {
      console.error("Error adding agent to user:", error);
      throw error;
    }
  },
  
  // ä»ç”¨æˆ·ç§»é™¤ä»£ç†
  async removeAgentFromUser(userId, agentId) {
    try {
      await pool.query(
        `DELETE FROM user_agents WHERE user_id = $1 AND agent_id = $2`,
        [userId, agentId]
      );
      
      // æ›´æ–°ç”¨æˆ·é…é¢
      await pool.query(
        `UPDATE user_quotas 
         SET current_agents = GREATEST(0, current_agents - 1), last_updated = NOW()
         WHERE user_id = $1`,
        [userId]
      );
    } catch (error) {
      console.error("Error removing agent from user:", error);
      throw error;
    }
  },
  
  // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®ä»£ç†
  async validateAgentAccess(userId, agentId) {
    try {
      const result = await pool.query(
        `SELECT * FROM user_agents WHERE user_id = $1 AND agent_id = $2`,
        [userId, agentId]
      );
      return result.rowCount > 0;
    } catch (error) {
      console.error("Error validating agent access:", error);
      throw error;
    }
  },
  
  // è·å–ç”¨æˆ·é…é¢ä¿¡æ¯
  async getUserQuota(userId) {
    try {
      // ç¡®ä¿ç”¨æˆ·å­˜åœ¨äºé…é¢è¡¨ä¸­
      await pool.query(
        `INSERT INTO user_quotas (user_id, current_agents)
         VALUES ($1, 0)
         ON CONFLICT (user_id) DO NOTHING`,
        [userId]
      );
      
      const result = await pool.query(
        `SELECT * FROM user_quotas WHERE user_id = $1`,
        [userId]
      );
      
      if (result.rowCount === 0) {
        return { used: 0, limit: 5, remaining: 5 };
      }
      
      const quota = result.rows[0];
      return {
        used: quota.current_agents,
        limit: quota.max_agents,
        remaining: Math.max(0, quota.max_agents - quota.current_agents)
      };
    } catch (error) {
      console.error("Error getting user quota:", error);
      throw error;
    }
  },
  
  // æ£€æŸ¥å¹¶æ›´æ–°ç”¨æˆ·é…é¢
  async checkAndUpdateQuota(userId) {
    try {
      // è·å–ç”¨æˆ·æ‹¥æœ‰çš„ä»£ç†æ•°é‡
      const agentsResult = await pool.query(
        `SELECT COUNT(*) as count FROM user_agents WHERE user_id = $1`,
        [userId]
      );
      
      const agentCount = parseInt(agentsResult.rows[0].count);
      
      // æ›´æ–°é…é¢è¡¨
      await pool.query(
        `UPDATE user_quotas 
         SET current_agents = $2, last_updated = NOW()
         WHERE user_id = $1`,
        [userId, agentCount]
      );
      
      return agentCount;
    } catch (error) {
      console.error("Error checking and updating quota:", error);
      throw error;
    }
  }
};

// è·å–ç”¨æˆ·çš„ä»£ç†åˆ—è¡¨
app.get('/agents', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // è·å–ç”¨æˆ·ä»£ç†åˆ—è¡¨
    const userAgents = await userAgentManager.getUserAgents(userId);
    
    // è·å–ä»£ç†è¯¦æƒ…
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents`);
    const elizaData = await elizaResponse.json();
    
    // å°†ç”¨æˆ·ä»£ç†ä¿¡æ¯ä¸Elizaä»£ç†è¯¦æƒ…åˆå¹¶
    const agents = userAgents.map(userAgent => {
      const elizaAgent = elizaData.agents.find(a => a.id === userAgent.agent_id);
      return {
        ...userAgent,
        id: userAgent.agent_id,
        status: elizaAgent ? 'running' : 'stopped',
        details: elizaAgent
      };
    });
    
    // è·å–ç”¨æˆ·é…é¢
    const quota = await userAgentManager.getUserQuota(userId);
    
    res.json({ agents, quota });
  } catch (error) {
    console.error("Error fetching agents:", error);
    res.status(500).json({ error: error.message });
  }
});

// è·å–å•ä¸ªä»£ç†è¯¦æƒ…
app.get('/agents/:agentId', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™è®¿é—®æ­¤ä»£ç†' });
    }
    
    // è·å–Elizaä»£ç†è¯¦æƒ…
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}`);
    
    if (!elizaResponse.ok) {
      return res.status(elizaResponse.status).json({ error: 'æ— æ³•è·å–ä»£ç†è¯¦æƒ…' });
    }
    
    const agentData = await elizaResponse.json();
    res.json(agentData);
  } catch (error) {
    console.error("Error fetching agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// åˆ›å»ºæ–°ä»£ç†
app.post('/agents', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const agentData = req.body;
    
    // æ£€æŸ¥ç”¨æˆ·é…é¢
    const quota = await userAgentManager.getUserQuota(userId);
    if (quota.remaining <= 0) {
      return res.status(403).json({ 
        error: 'æ‚¨å·²è¾¾åˆ°ä»£ç†æ•°é‡ä¸Šé™', 
        quota 
      });
    }
    
    // è°ƒç”¨Eliza APIåˆ›å»ºä»£ç†
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...agentData,
        metadata: {
          ...agentData.metadata,
          ownerId: userId
        }
      })
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    // è·å–åˆ›å»ºçš„ä»£ç†ä¿¡æ¯
    const newAgent = await elizaResponse.json();
    
    // è®°å½•ç”¨æˆ·å’Œä»£ç†çš„å…³ç³»
    await userAgentManager.addAgentToUser(
      userId, 
      newAgent.id, 
      agentData.name, 
      agentData.description || ''
    );
    
    res.status(201).json(newAgent);
  } catch (error) {
    console.error("Error creating agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// åˆ é™¤ä»£ç†
app.delete('/agents/:agentId', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™åˆ é™¤æ­¤ä»£ç†' });
    }
    
    // è°ƒç”¨Eliza APIåˆ é™¤ä»£ç†
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}`, {
      method: 'DELETE'
    });
    
    // ç§»é™¤ç”¨æˆ·ä¸ä»£ç†çš„å…³ç³»
    await userAgentManager.removeAgentFromUser(userId, agentId);
    
    res.status(204).send();
  } catch (error) {
    console.error("Error deleting agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// å¯åŠ¨ä»£ç†
app.post('/agents/:agentId/start', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™å¯åŠ¨æ­¤ä»£ç†' });
    }
    
    // è°ƒç”¨Eliza APIå¯åŠ¨ä»£ç†
    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾Elizaæœ‰startç«¯ç‚¹ï¼Œæ ¹æ®å®é™…APIè°ƒæ•´
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}/start`, {
      method: 'POST'
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    const result = await elizaResponse.json();
    res.json(result);
  } catch (error) {
    console.error("Error starting agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// åœæ­¢ä»£ç†
app.post('/agents/:agentId/stop', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™åœæ­¢æ­¤ä»£ç†' });
    }
    
    // è°ƒç”¨Eliza APIåœæ­¢ä»£ç†
    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾Elizaæœ‰stopç«¯ç‚¹ï¼Œæ ¹æ®å®é™…APIè°ƒæ•´
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}/stop`, {
      method: 'POST'
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    const result = await elizaResponse.json();
    res.json(result);
  } catch (error) {
    console.error("Error stopping agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// å‘é€æ¶ˆæ¯ç»™ä»£ç†
app.post('/agents/:agentId/message', authenticate, upload.single('file'), async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    const { text } = req.body;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™ä¸æ­¤ä»£ç†å¯¹è¯' });
    }
    
    // å‡†å¤‡å‘é€æ¶ˆæ¯
    const formData = new FormData();
    formData.append('text', text);
    formData.append('user', userId);
    
    // å¦‚æœæœ‰æ–‡ä»¶ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
    if (req.file) {
      const fileBuffer = Buffer.from(await fs.readFile(req.file.path));
      formData.append('file', new Blob([fileBuffer]), req.file.originalname);
    }
    

---

_**User**_

æ˜¯å¦å®Œæˆï¼Ÿ

---

_**Assistant**_

è¿˜æ²¡æœ‰å®Œæˆå®Œæ•´çš„å®ç°ï¼Œæˆ‘éœ€è¦ç»§ç»­æä¾›ä»£ç çš„å…¶ä½™éƒ¨åˆ†ã€‚ä»¥ä¸‹æ˜¯ç»§ç»­çš„éƒ¨åˆ†ï¼š

## 3. ç»§ç»­ä¸­é—´å±‚æœåŠ¡å™¨APIæ¥å£

```javascript
// å‘é€æ¶ˆæ¯ç»™ä»£ç†ï¼ˆç»§ç»­ï¼‰
    // è°ƒç”¨Eliza APIå‘é€æ¶ˆæ¯
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}/message`, {
      method: 'POST',
      body: formData
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    const result = await elizaResponse.json();
    
    // æ›´æ–°ä»£ç†æœ€åä½¿ç”¨æ—¶é—´
    await pool.query(
      `UPDATE user_agents SET last_used = NOW() WHERE user_id = $1 AND agent_id = $2`,
      [userId, agentId]
    );
    
    res.json(result);
  } catch (error) {
    console.error("Error sending message:", error);
    res.status(500).json({ error: error.message });
  }
});

// è·å–æ¨¡æ¿åˆ—è¡¨
app.get('/agent-templates', authenticate, async (req, res) => {
  try {
    // è°ƒç”¨Eliza APIè·å–æ¨¡æ¿
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agent-templates`);
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    const templates = await elizaResponse.json();
    res.json(templates);
  } catch (error) {
    console.error("Error fetching templates:", error);
    res.status(500).json({ error: error.message });
  }
});

// ä»æ¨¡æ¿åˆ›å»ºä»£ç†
app.post('/agent-templates/:templateId/create', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { templateId } = req.params;
    const customizations = req.body;
    
    // æ£€æŸ¥ç”¨æˆ·é…é¢
    const quota = await userAgentManager.getUserQuota(userId);
    if (quota.remaining <= 0) {
      return res.status(403).json({ 
        error: 'æ‚¨å·²è¾¾åˆ°ä»£ç†æ•°é‡ä¸Šé™', 
        quota 
      });
    }
    
    // è°ƒç”¨Eliza APIä»æ¨¡æ¿åˆ›å»ºä»£ç†
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agent-templates/${templateId}/create`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...customizations,
        metadata: {
          ...customizations.metadata,
          ownerId: userId
        }
      })
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    // è·å–åˆ›å»ºçš„ä»£ç†ä¿¡æ¯
    const newAgent = await elizaResponse.json();
    
    // è®°å½•ç”¨æˆ·å’Œä»£ç†çš„å…³ç³»
    await userAgentManager.addAgentToUser(
      userId, 
      newAgent.id, 
      customizations.name || newAgent.name, 
      customizations.description || newAgent.description || ''
    );
    
    res.status(201).json(newAgent);
  } catch (error) {
    console.error("Error creating agent from template:", error);
    res.status(500).json({ error: error.message });
  }
});

// è·å–ç”¨æˆ·ä»£ç†é…é¢
app.get('/user/agent-quota', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // ç¡®ä¿é…é¢æ•°æ®æ˜¯æœ€æ–°çš„
    await userAgentManager.checkAndUpdateQuota(userId);
    
    // è·å–é…é¢ä¿¡æ¯
    const quota = await userAgentManager.getUserQuota(userId);
    res.json(quota);
  } catch (error) {
    console.error("Error fetching quota:", error);
    res.status(500).json({ error: error.message });
  }
});

// å¯åŠ¨æœåŠ¡å™¨
app.listen(PORT, () => {
  console.log(`Agent middleware service running on port ${PORT}`);
});
```

## 4. åˆ›å»ºReactç»„ä»¶éƒ¨åˆ†

### 4.1 ä»£ç†åˆ—è¡¨ç»„ä»¶

```jsx
// src/components/agents/AgentList.jsx
import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { 
  fetchUserAgents, 
  setSelectedAgent, 
  deleteAgent,
  startAgent,
  stopAgent
} from '../redux/agentSlice';
import { Typography, Button, Card, List, Divider, Tag, Space, Modal, Progress, Tooltip } from 'antd';
import { 
  PlayCircleOutlined, 
  PauseCircleOutlined, 
  DeleteOutlined, 
  EditOutlined,
  PlusOutlined,
  ExclamationCircleOutlined
} from '@ant-design/icons';
import { useNavigate } from 'react-router-dom';

const { Title, Text } = Typography;
const { confirm } = Modal;

const AgentList = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { agents, loading, userQuota } = useSelector((state) => state.agents);
  const { currentUser } = useSelector((state) => state.app);
  
  useEffect(() => {
    if (currentUser) {
      dispatch(fetchUserAgents());
    }
  }, [dispatch, currentUser]);
  
  const handleAgentSelect = (agent) => {
    dispatch(setSelectedAgent(agent));
    navigate(`/agents/${agent.id}`);
  };
  
  const handleDeleteAgent = (agentId, e) => {
    e.stopPropagation();
    
    confirm({
      title: 'ç¡®è®¤åˆ é™¤',
      icon: <ExclamationCircleOutlined />,
      content: 'åˆ é™¤æ­¤ä»£ç†åå°†æ— æ³•æ¢å¤ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
      okText: 'åˆ é™¤',
      okType: 'danger',
      cancelText: 'å–æ¶ˆ',
      onOk() {
        dispatch(deleteAgent(agentId));
      }
    });
  };
  
  const handleStartAgent = (agentId, e) => {
    e.stopPropagation();
    dispatch(startAgent(agentId));
  };
  
  const handleStopAgent = (agentId, e) => {
    e.stopPropagation();
    dispatch(stopAgent(agentId));
  };
  
  const renderAgentStatus = (status) => {
    switch(status) {
      case 'running':
        return <Tag color="green">è¿è¡Œä¸­</Tag>;
      case 'stopped':
        return <Tag color="red">å·²åœæ­¢</Tag>;
      default:
        return <Tag color="default">æœªçŸ¥</Tag>;
    }
  };
  
  const getStatusAction = (agent) => {
    return agent.status === 'running' ? (
      <Tooltip title="åœæ­¢ä»£ç†">
        <Button 
          icon={<PauseCircleOutlined />} 
          onClick={(e) => handleStopAgent(agent.id, e)}
          type="text"
        />
      </Tooltip>
    ) : (
      <Tooltip title="å¯åŠ¨ä»£ç†">
        <Button 
          icon={<PlayCircleOutlined />} 
          onClick={(e) => handleStartAgent(agent.id, e)}
          type="text"
        />
      </Tooltip>
    );
  };
  
  return (
    <div className="agent-list-container">
      <div className="agent-list-header">
        <Title level={3}>æˆ‘çš„ä»£ç†</Title>
        <Space>
          <Progress 
            type="circle" 
            percent={Math.round((userQuota.used / userQuota.limit) * 100)} 
            format={() => `${userQuota.used}/${userQuota.limit}`} 
            size="small" 
            width={60}
          />
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => navigate('/agents/create')}
            disabled={userQuota.remaining <= 0}
          >
            åˆ›å»ºä»£ç†
          </Button>
        </Space>
      </div>
      
      <Divider />
      
      {agents.length === 0 ? (
        <div className="empty-state">
          <Text>æ‚¨è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ä»£ç†</Text>
          <Button 
            type="primary" 
            icon={<PlusOutlined />}
            onClick={() => navigate('/agents/create')}
          >
            åˆ›å»ºç¬¬ä¸€ä¸ªä»£ç†
          </Button>
        </div>
      ) : (
        <List
          grid={{ gutter: 16, column: 3 }}
          dataSource={agents}
          loading={loading}
          renderItem={agent => (
            <List.Item>
              <Card 
                hoverable
                onClick={() => handleAgentSelect(agent)}
                className="agent-card"
                actions={[
                  getStatusAction(agent),
                  <Tooltip title="ç¼–è¾‘ä»£ç†">
                    <Button 
                      icon={<EditOutlined />} 
                      onClick={(e) => {
                        e.stopPropagation();
                        navigate(`/agents/edit/${agent.id}`);
                      }}
                      type="text"
                    />
                  </Tooltip>,
                  <Tooltip title="åˆ é™¤ä»£ç†">
                    <Button 
                      icon={<DeleteOutlined />} 
                      onClick={(e) => handleDeleteAgent(agent.id, e)}
                      type="text"
                      danger
                    />
                  </Tooltip>
                ]}
              >
                <Card.Meta
                  title={
                    <Space>
                      {agent.name}
                      {renderAgentStatus(agent.status)}
                    </Space>
                  }
                  description={agent.description || 'æ— æè¿°'}
                />
                <div className="agent-card-footer">
                  <Text type="secondary">
                    æœ€åä½¿ç”¨: {new Date(agent.last_used).toLocaleString()}
                  </Text>
                </div>
              </Card>
            </List.Item>
          )}
        />
      )}
    </div>
  );
};

export default AgentList;
```

### 4.2 ä»£ç†åˆ›å»ºç»„ä»¶

```jsx
// src/components/agents/CreateAgent.jsx
import React, { useState, useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { createAgent, fetchTemplates, createAgentFromTemplate } from '../redux/agentSlice';
import { 
  Form, 
  Input, 
  Button, 
  Card, 
  Tabs, 
  Select, 
  Divider,
  Typography,
  Upload,
  message,
  Spin,
  Radio
} from 'antd';
import { UploadOutlined, RobotOutlined, FileTextOutlined } from '@ant-design/icons';
import { useNavigate } from 'react-router-dom';

const { Title, Text } = Typography;
const { TextArea } = Input;
const { TabPane } = Tabs;

const CreateAgent = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { loading, templates } = useSelector((state) => state.agents);
  const { currentUser } = useSelector((state) => state.app);
  
  const [form] = Form.useForm();
  const [templateForm] = Form.useForm();
  const [activeTab, setActiveTab] = useState('custom');
  const [selectedTemplate, setSelectedTemplate] = useState(null);
  
  useEffect(() => {
    if (currentUser) {
      dispatch(fetchTemplates());
    }
  }, [dispatch, currentUser]);
  
  const handleSubmitCustomAgent = (values) => {
    const agentData = {
      name: values.name,
      description: values.description,
      model: values.model,
      personality: values.personality,
      systemInstructions: values.systemInstructions,
      knowledgeBase: values.knowledgeBase || []
    };
    
    dispatch(createAgent(agentData)).then((response) => {
      if (!response.error) {
        message.success('ä»£ç†åˆ›å»ºæˆåŠŸ');
        navigate('/agents');
      }
    });
  };
  
  const handleSubmitTemplateAgent = (values) => {
    const customizations = {
      name: values.name,
      description: values.description || selectedTemplate.description,
      customizationOptions: values.customizationOptions || {}
    };
    
    dispatch(createAgentFromTemplate({
      templateId: selectedTemplate.id,
      customizations
    })).then((response) => {
      if (!response.error) {
        message.success('ä»£ç†åˆ›å»ºæˆåŠŸ');
        navigate('/agents');
      }
    });
  };
  
  const handleSelectTemplate = (template) => {
    setSelectedTemplate(template);
    templateForm.setFieldsValue({
      name: `${template.name} - ${currentUser}çš„å‰¯æœ¬`,
      description: template.description
    });
  };
  
  const renderTemplateOptions = () => {
    if (!selectedTemplate) {
      return (
        <div className="template-select">
          <Title level={4}>é€‰æ‹©ä¸€ä¸ªæ¨¡æ¿</Title>
          <div className="template-cards">
            {templates.map(template => (
              <Card
                key={template.id}
                hoverable
                className="template-card"
                onClick={() => handleSelectTemplate(template)}
              >
                <Card.Meta
                  title={template.name}
                  description={template.description}
                />
              </Card>
            ))}
          </div>
        </div>
      );
    }
    
    return (
      <Form
        form={templateForm}
        layout="vertical"
        onFinish={handleSubmitTemplateAgent}
      >
        <Title level={4}>è‡ªå®šä¹‰ä½ çš„ä»£ç†</Title>
        <Text type="secondary">åŸºäºæ¨¡æ¿: {selectedTemplate.name}</Text>
        
        <Form.Item
          name="name"
          label="ä»£ç†åç§°"
          rules={[{ required: true, message: 'è¯·è¾“å…¥ä»£ç†åç§°' }]}
        >
          <Input placeholder="ä¸ºä½ çš„ä»£ç†èµ·ä¸ªåå­—" />
        </Form.Item>
        
        <Form.Item
          name="description"
          label="æè¿°"
        >
          <TextArea 
            placeholder="æè¿°è¿™ä¸ªä»£ç†çš„ç”¨é€”" 
            autoSize={{ minRows: 2, maxRows: 4 }}
          />
        </Form.Item>
        
        {selectedTemplate.customizationFields && 
          selectedTemplate.customizationFields.map(field => (
            <Form.Item
              key={field.id}
              name={['customizationOptions', field.id]}
              label={field.label}
              rules={field.required ? [{ required: true, message: `è¯·è®¾ç½®${field.label}` }] : []}
            >
              {field.type === 'text' ? (
                <Input placeholder={field.placeholder || ''} />
              ) : field.type === 'textarea' ? (
                <TextArea 
                  placeholder={field.placeholder || ''} 
                  autoSize={{ minRows: 2, maxRows: 6 }}
                />
              ) : field.type === 'select' ? (
                <Select
                  placeholder={field.placeholder || 'è¯·é€‰æ‹©'}
                  options={field.options.map(opt => ({
                    label: opt.label,
                    value: opt.value
                  }))}
                />
              ) : null}
            </Form.Item>
          ))}
        
        <Form.Item>
          <Button type="primary" htmlType="submit" loading={loading}>
            åˆ›å»ºä»£ç†
          </Button>
          <Button 
            style={{ marginLeft: 8 }} 
            onClick={() => setSelectedTemplate(null)}
          >
            è¿”å›æ¨¡æ¿åˆ—è¡¨
          </Button>
        </Form.Item>
      </Form>
    );
  };
  
  return (
    <div className="create-agent-container">
      <Title level={2}>åˆ›å»ºæ–°ä»£ç†</Title>
      
      <Tabs 
        activeKey={activeTab} 
        onChange={setActiveTab}
      >
        <TabPane 
          tab={<span><RobotOutlined />è‡ªå®šä¹‰ä»£ç†</span>} 
          key="custom"
        >
          <Form
            form={form}
            layout="vertical"
            onFinish={handleSubmitCustomAgent}
          >
            <Form.Item
              name="name"
              label="ä»£ç†åç§°"
              rules={[{ required: true, message: 'è¯·è¾“å…¥ä»£ç†åç§°' }]}
            >
              <Input placeholder="ä¸ºä½ çš„ä»£ç†èµ·ä¸ªåå­—" />
            </Form.Item>
            
            <Form.Item
              name="description"
              label="æè¿°"
            >
              <TextArea 
                placeholder="æè¿°è¿™ä¸ªä»£ç†çš„ç”¨é€”" 
                autoSize={{ minRows: 2, maxRows: 4 }}
              />
            </Form.Item>
            
            <Form.Item
              name="model"
              label="æ¨¡å‹"
              rules={[{ required: true, message: 'è¯·é€‰æ‹©æ¨¡å‹' }]}
              initialValue="gpt-4o"
            >
              <Select placeholder="é€‰æ‹©è¯­è¨€æ¨¡å‹">
                <Select.Option value="gpt-4o">GPT-4o</Select.Option>
                <Select.Option value="gpt-3.5-turbo">GPT-3.5 Turbo</Select.Option>
                <Select.Option value="claude-3-sonnet">Claude 3 Sonnet</Select.Option>
                <Select.Option value="claude-3-opus">Claude 3 Opus</Select.Option>
              </Select>
            </Form.Item>
            
            <Form.Item
              name="personality"
              label="ä¸ªæ€§è®¾å®š"
            >
              <TextArea 
                placeholder="æè¿°ä»£ç†çš„ä¸ªæ€§ç‰¹ç‚¹" 
                autoSize={{ minRows: 3, maxRows: 6 }}
              />
            </Form.Item>
            
            <Form.Item
              name="systemInstructions"
              label="ç³»ç»ŸæŒ‡ä»¤"
              rules={[{ required: true, message: 'è¯·è¾“å…¥ç³»ç»ŸæŒ‡ä»¤' }]}
            >
              <TextArea 
                placeholder="å®šä¹‰ä»£ç†çš„è§’è‰²å’Œä»»åŠ¡" 
                autoSize={{ minRows: 4, maxRows: 8 }}
              />
            </Form.Item>
            
            <Form.Item
              name="knowledgeBase"
              label="çŸ¥è¯†åº“"
            >
              <Upload
                multiple
                beforeUpload={() => false}
                listType="text"
              >
                <Button icon={<UploadOutlined />}>ä¸Šä¼ æ–‡ä»¶</Button>
              </Upload>
            </Form.Item>
            
            <Form.Item>
              <Button type="primary" htmlType="submit" loading={loading}>
                åˆ›å»ºä»£ç†
              </Button>
            </Form.Item>
          </Form>
        </TabPane>
        
        <TabPane 
          tab={<span><FileTextOutlined />ä½¿ç”¨æ¨¡æ¿</span>} 
          key="template"
        >
          {loading ? (
            <div className="template-loading">
              <Spin size="large" />
              <Text>åŠ è½½æ¨¡æ¿ä¸­...</Text>
            </div>
          ) : renderTemplateOptions()}
        </TabPane>
      </Tabs>
    </div>
  );
};

export default CreateAgent;
```

### 4.3 ä»£ç†è¯¦æƒ…/èŠå¤©ç•Œé¢ç»„ä»¶

```jsx
// src/components/agents/AgentChat.jsx
import React, { useEffect, useState, useRef } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useParams } from 'react-router-dom';
import { 
  fetchUserAgents,
  setSelectedAgent
} from '../redux/agentSlice';
import { 
  Typography, 
  Input, 
  Button, 
  Avatar, 
  Divider, 
  Space, 
  Upload, 
  message,
  Spin,
  Card,
  Tooltip
} from 'antd';
import { 
  SendOutlined, 
  PaperClipOutlined, 
  RobotOutlined,
  UserOutlined,
  SettingOutlined,
  ReloadOutlined
} from '@ant-design/icons';
import agentService from '../../services/agentService';

const { Title, Text, Paragraph } = Typography;

const AgentChat = () => {
  const dispatch = useDispatch();
  const { agentId } = useParams();
  const { agents, selectedAgent } = useSelector((state) => state.agents);
  const { currentUser } = useSelector((state) => state.app);
  
  const [messages, setMessages] = useState([]);
  const [inputMessage, setInputMessage] = useState('');
  const [loading, setLoading] = useState(false);
  const [file, setFile] = useState(null);
  const [agentTyping, setAgentTyping] = useState(false);
  
  const messagesEndRef = useRef(null);
  const chatContainerRef = useRef(null);
  
  // è·å–ä»£ç†ä¿¡æ¯
  useEffect(() => {
    if (agentId && (!selectedAgent || selectedAgent.id !== agentId)) {
      // å°è¯•ä»å·²åŠ è½½çš„ä»£ç†ä¸­æŸ¥æ‰¾
      const agent = agents.find(a => a.id === agentId);
      if (agent) {
        dispatch(setSelectedAgent(agent));
      } else {
        // å¦‚æœæ‰¾ä¸åˆ°ï¼Œé‡æ–°åŠ è½½ç”¨æˆ·çš„ä»£ç†
        dispatch(fetchUserAgents()).then(response => {
          if (!response.error) {
            const agent = response.payload.agents.find(a => a.id === agentId);
            if (agent) {
              dispatch(setSelectedAgent(agent));
            }
          }
        });
      }
    }
  }, [agentId, agents, dispatch, selectedAgent]);
  
  // åˆå§‹åŠ è½½èŠå¤©å†å²
  useEffect(() => {
    if (agentId) {
      setLoading(true);
      agentService.getAgent(agentId)
        .then(response => {
          // åŠ è½½èŠå¤©å†å²ï¼Œå¦‚æœAPIæ”¯æŒçš„è¯
          if (response.data.messages) {
            setMessages(response.data.messages);
          } else {
            // å¦åˆ™åˆå§‹åŒ–ç©ºèŠå¤©
            setMessages([
              {
                sender: 'agent',
                content: `ä½ å¥½ï¼Œæˆ‘æ˜¯${response.data.name}ã€‚æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ`,
                timestamp: new Date().toISOString()
              }
            ]);
          }
        })
        .catch(error => {
          console.error("Error loading agent:", error);
          message.error('åŠ è½½ä»£ç†ä¿¡æ¯å¤±è´¥');
        })
        .finally(() => {
          setLoading(false);
        });
    }
  }, [agentId]);
  
  // æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);
  
  const handleFileChange = (info) => {
    if (info.fileList.length > 0) {
      setFile(info.fileList[0].originFileObj);
    } else {
      setFile(null);
    }
  };
  
  const handleSendMessage = () => {
    if (!inputMessage.trim() && !file) return;
    
    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°èŠå¤©
    const userMessage = {
      sender: 'user',
      content: inputMessage.trim(),
      timestamp: new Date().toISOString()
    };
    
    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setAgentTyping(true);
    
    // è°ƒç”¨APIå‘é€æ¶ˆæ¯
    agentService.sendMessage(agentId, inputMessage, file)
      .then(response => {
        // æ·»åŠ ä»£ç†å“åº”åˆ°èŠå¤©
        setMessages(prev => [
          ...prev,
          {
            sender: 'agent',
            content: response.data.response || response.data.text || 'å¤„ç†å®Œæˆ',
            timestamp: new Date().toISOString()
          }
        ]);
      })
      .catch(error => {
        console.error("Error sending message:", error);
        message.error('å‘é€æ¶ˆæ¯å¤±è´¥');
        
        // æ·»åŠ é”™è¯¯ä¿¡æ¯åˆ°èŠå¤©
        setMessages(prev => [
          ...prev,
          {
            sender: 'system',
            content: 'æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œè¯·ç¨åå†è¯•ã€‚',
            timestamp: new Date().toISOString(),
            error: true
          }
        ]);
      })
      .finally(() => {
        setAgentTyping(false);
        setFile(null);
      });
  };
  
  const renderMessage = (msg, index) => {
    const isUser = msg.sender === 'user';
    const isSystem = msg.sender === 'system';
    
    return (
      <div key={index} className={`message-container ${isUser ? 'user-message' : 'agent-message'}`}>
        <div className="message-avatar">
          {isUser ? (
            <Avatar icon={<UserOutlined />} style={{ backgroundColor: '#1890ff' }} />
          ) : isSystem ? (
            <Avatar icon={<SettingOutlined />} style={{ backgroundColor: '#f56a00' }} />
          ) : (
            <Avatar icon={<RobotOutlined />} style={{ backgroundColor: '#52c41a' }} />
          )}
        </div>
        <div className={`message-content ${msg.error ? 'error-message' : ''}`}>
          <Paragraph>{msg.content}</Paragraph>
          <div className="message-time">
            <Text type="secondary" style={{ fontSize: '12px' }}>
              {new Date(msg.timestamp).toLocaleTimeString()}
            </Text>
          </div>
        </div>
      </div>
    );
  };
  
  return (
    <div className="agent-chat-container">
      {loading ? (
        <div className="loading-container">
          <Spin size="large" />
          <Text>åŠ è½½ä¸­...</Text>
        </div>
      ) : (
        <>
          <div className="chat-header">
            <Space align="center">
              <Avatar icon={<RobotOutlined />} size="large" style={{ backgroundColor: '#52c41a' }} />
              <div>
                <Title level={4} style={{ margin: 0 }}>
                  {selectedAgent?.name || 'ä»£ç†'}
                </Title>
                <Text type="secondary">
                  {selectedAgent?.status === 'running' ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                </Text>
              </div>
            </Space>
            <Space>
              <Tooltip title="åˆ·æ–°ä¼šè¯">
                <Button 
                  icon={<ReloadOutlined />} 
                  onClick={() => {
                    if (window.confirm('ç¡®å®šè¦åˆ·æ–°ä¼šè¯å—ï¼Ÿè¿™å°†æ¸…é™¤å½“å‰çš„å¯¹è¯ã€‚')) {
                      setMessages([
                        {
                          sender: 'agent',
                          content: `ä½ å¥½ï¼Œæˆ‘æ˜¯${selectedAgent?.name}ã€‚æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®åŠ©ä½ çš„å—ï¼Ÿ`,
                          timestamp: new Date().toISOString()
                        }
                      ]);
                    }
                  }}
                />
              </Tooltip>
              <Tooltip title="è®¾ç½®">
                <Button icon={<SettingOutlined />} />
              </Tooltip>
            </Space>
          </div>
          
          <Divider style={{ margin: '0 0 8px 0' }} />
          
          <div className="chat-messages" ref={chatContainerRef}>
            {messages.map((message, index) => renderMessage(message, index))}
            
            {agentTyping && (
              <div className="typing-indicator">
                <Text type="secondary">ä»£ç†æ­£åœ¨è¾“å…¥...</Text>
                <Spin size="small" />
              </div>
            )}
            
            <div ref={messagesEndRef} />
          </div>
          
          <div className="chat-input">
            <Input.Group compact>
              <Upload
                beforeUpload={() => false}
                onChange={handleFileChange}
                showUploadList={false}
                maxCount={1}
              >
                <Button icon={<PaperClipOutlined />} />
              </Upload>
              <Input 
                value={inputMessage}
                onChange={e => setInputMessage(e.target.value)}
                onPressEnter={handleSendMessage}
                placeholder="è¾“å…¥æ¶ˆæ¯..."
                disabled={agentTyping}
                style={{ width: 'calc(100% - 96px)' }}
              />
              <Button 
                type="primary" 
                icon={<SendOutlined />} 
                onClick={handleSendMessage}
                disabled={agentTyping || (!inputMessage.trim() && !file)}
              />
            </Input.Group>
            {file && (
              <div className="file-preview">
                <Text style={{ marginRight: 8 }}>é™„ä»¶: {file.name}</Text>
                <Button 
                  size="small" 
                  danger
                  onClick={() => setFile(null)}
                >
                  åˆ é™¤
                </Button>
              </div>
            )}
          </div>
        </>
      )}
    </div>
  );
};

export default AgentChat;
```

## 5. è·¯ç”±é…ç½®å’Œæ•´åˆ

```jsx
// src/App.jsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { useDispatch, useSelector } from 'react-redux';
import { Layout } from 'antd';

// å¯¼å…¥ç»„ä»¶
import Header from './components/layout/Header';
import Sidebar from './components/layout/Sidebar';
import Login from './components/auth/Login';
import Home from './components/Home';
import AgentList from './components/agents/AgentList';
import CreateAgent from './components/agents/CreateAgent';
import AgentChat from './components/agents/AgentChat';
import UserProfile from './components/profile/UserProfile';

// å¯¼å…¥æ ·å¼
import './App.css';

const { Content } = Layout;

// è·¯ç”±ä¿æŠ¤ç»„ä»¶
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useSelector((state) => state

---

_**User**_

ç»§ç»­

---

_**Assistant**_

è®©æˆ‘ç»§ç»­å®Œæˆä»£ç ï¼š

```jsx
// src/App.jsx (ç»§ç»­)
const ProtectedRoute = ({ children }) => {
  const { isLoggedIn } = useSelector((state) => state.app);
  
  if (!isLoggedIn) {
    return <Navigate to="/login" replace />;
  }
  
  return children;
};

const App = () => {
  const { isLoggedIn } = useSelector((state) => state.app);
  
  return (
    <Router>
      <Layout style={{ minHeight: '100vh' }}>
        {isLoggedIn && <Header />}
        <Layout>
          {isLoggedIn && <Sidebar />}
          <Content className="site-content">
            <Routes>
              <Route path="/login" element={<Login />} />
              
              <Route path="/" element={
                <ProtectedRoute>
                  <Home />
                </ProtectedRoute>
              } />
              
              <Route path="/agents" element={
                <ProtectedRoute>
                  <AgentList />
                </ProtectedRoute>
              } />
              
              <Route path="/agents/create" element={
                <ProtectedRoute>
                  <CreateAgent />
                </ProtectedRoute>
              } />
              
              <Route path="/agents/:agentId" element={
                <ProtectedRoute>
                  <AgentChat />
                </ProtectedRoute>
              } />
              
              <Route path="/agents/edit/:agentId" element={
                <ProtectedRoute>
                  <CreateAgent />
                </ProtectedRoute>
              } />
              
              <Route path="/profile" element={
                <ProtectedRoute>
                  <UserProfile />
                </ProtectedRoute>
              } />
              
              <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
          </Content>
        </Layout>
      </Layout>
    </Router>
  );
};

export default App;
```

## 6. æ›´æ–°storeé…ç½®æ¥é›†æˆä»£ç†Slice

```jsx
// src/store.js
import { configureStore } from '@reduxjs/toolkit';
import appReducer from './components/redux/appSlice';
import agentReducer from './components/redux/agentSlice';

const store = configureStore({
  reducer: {
    app: appReducer,
    agents: agentReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // å¿½ç•¥æŸäº›éå¯åºåˆ—åŒ–çš„å€¼
        ignoredActions: ['agents/createAgent/fulfilled'],
        ignoredPaths: ['agents.selectedAgent.file'],
      },
    }),
});

export default store;
```

## 7. è¾¹æ å¯¼èˆªç»„ä»¶

```jsx
// src/components/layout/Sidebar.jsx
import React from 'react';
import { useSelector } from 'react-redux';
import { Layout, Menu } from 'antd';
import { 
  HomeOutlined, 
  RobotOutlined, 
  TeamOutlined, 
  SettingOutlined,
  BookOutlined,
  UserOutlined
} from '@ant-design/icons';
import { useLocation, useNavigate } from 'react-router-dom';

const { Sider } = Layout;

const Sidebar = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { currentUser } = useSelector((state) => state.app);
  
  const getSelectedKeys = () => {
    const path = location.pathname;
    if (path === '/') return ['home'];
    if (path.startsWith('/agents')) return ['agents'];
    if (path.startsWith('/profile')) return ['profile'];
    return [];
  };
  
  return (
    <Sider width={200} className="site-sidebar" collapsible>
      <div className="logo">
        <h2>Elizaå¹³å°</h2>
      </div>
      <Menu
        mode="inline"
        selectedKeys={getSelectedKeys()}
        style={{ height: '100%', borderRight: 0 }}
        onClick={({ key }) => {
          switch(key) {
            case 'home':
              navigate('/');
              break;
            case 'agents':
              navigate('/agents');
              break;
            case 'profile':
              navigate('/profile');
              break;
            default:
              break;
          }
        }}
      >
        <Menu.Item key="home" icon={<HomeOutlined />}>
          é¦–é¡µ
        </Menu.Item>
        <Menu.Item key="agents" icon={<RobotOutlined />}>
          æˆ‘çš„ä»£ç†
        </Menu.Item>
        <Menu.Item key="profile" icon={<UserOutlined />}>
          ä¸ªäººèµ„æ–™
        </Menu.Item>
      </Menu>
    </Sider>
  );
};

export default Sidebar;
```

## 8. CSSæ ·å¼è¡¨

```css
/* src/components/agents/Agents.css */
/* ä»£ç†åˆ—è¡¨æ ·å¼ */
.agent-list-container {
  padding: 20px;
}

.agent-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  background: #f9f9f9;
  border-radius: 8px;
  text-align: center;
}

.empty-state button {
  margin-top: 16px;
}

.agent-card {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.agent-card-footer {
  margin-top: 16px;
  border-top: 1px solid #f0f0f0;
  padding-top: 8px;
}

/* ä»£ç†åˆ›å»ºé¡µé¢æ ·å¼ */
.create-agent-container {
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
}

.template-select {
  padding: 16px;
}

.template-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 16px;
  margin-top: 16px;
}

.template-card {
  height: 100%;
}

.template-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
}

/* èŠå¤©ç•Œé¢æ ·å¼ */
.agent-chat-container {
  height: calc(100vh - 64px);
  display: flex;
  flex-direction: column;
  background: #f5f5f5;
}

.chat-header {
  padding: 12px 16px;
  background: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #f0f0f0;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
}

.message-container {
  margin-bottom: 16px;
  display: flex;
  max-width: 80%;
}

.user-message {
  align-self: flex-end;
  flex-direction: row-reverse;
}

.agent-message {
  align-self: flex-start;
}

.message-avatar {
  margin: 0 8px;
}

.message-content {
  background: white;
  padding: 8px 12px;
  border-radius: 8px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.user-message .message-content {
  background: #1890ff;
  color: white;
}

.error-message {
  background: #fff2f0 !important;
  border: 1px solid #ffccc7;
}

.typing-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0;
}

.chat-input {
  padding: 16px;
  background: white;
  border-top: 1px solid #f0f0f0;
}

.file-preview {
  margin-top: 8px;
  padding: 4px 8px;
  background: #f9f9f9;
  border-radius: 4px;
  display: flex;
  align-items: center;
}

.loading-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
```

## 9. ä¿®æ”¹index.jsä»¥ä½¿ç”¨Redux Store

```jsx
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import store from './store';
import App from './App';
import { ConfigProvider } from 'antd';
import zhCN from 'antd/lib/locale/zh_CN';
import 'antd/dist/antd.css';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <ConfigProvider locale={zhCN}>
        <App />
      </ConfigProvider>
    </Provider>
  </React.StrictMode>
);
```

## 10. è®¤è¯æœåŠ¡è¾…åŠ©å‡½æ•°

```javascript
// src/services/authService.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:4000';

// ç™»å½•æœåŠ¡
const login = async (username, password) => {
  try {
    const response = await axios.post(`${API_URL}/auth/login`, {
      username,
      password
    });
    
    if (response.data.token) {
      localStorage.setItem('token', response.data.token);
      localStorage.setItem('currentUser', username);
      localStorage.setItem('isLoggedIn', 'true');
    }
    
    return response.data;
  } catch (error) {
    throw error;
  }
};

// ç™»å‡º
const logout = () => {
  localStorage.removeItem('token');
  localStorage.removeItem('currentUser');
  localStorage.removeItem('isLoggedIn');
};

// è·å–è®¤è¯å¤´ä¿¡æ¯
const getAuthHeader = () => {
  const token = localStorage.getItem('token');
  return token ? { Authorization: `Bearer ${token}` } : {};
};

// åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
const isLoggedIn = () => {
  return localStorage.getItem('isLoggedIn') === 'true';
};

export {
  login,
  logout,
  getAuthHeader,
  isLoggedIn
};
```

## å®ç°æ€»ç»“

ä»¥ä¸Šä»£ç æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„æ··åˆå¼¹æ€§æ¨¡å¼ä»£ç†ç®¡ç†ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š

1. å‰ç«¯ä»£ç†ç®¡ç†ç•Œé¢ï¼ŒåŸºäºReactå’ŒRedux
2. ä¸­é—´å±‚APIæœåŠ¡ï¼Œä½œä¸ºå¤šç”¨æˆ·ç¯å¢ƒä¸‹å‰ç«¯å’ŒElizaåç«¯ä¹‹é—´çš„è¿æ¥å™¨
3. æ•°æ®åº“ç®¡ç†ç”¨æˆ·-ä»£ç†å…³ç³»å’Œé…é¢
4. å®Œæ•´çš„CRUDæ“ä½œæ”¯æŒä»£ç†çš„åˆ›å»ºã€æŸ¥è¯¢ã€æ›´æ–°å’Œåˆ é™¤
5. ä¸`appSlice.jsx`ç°æœ‰ç”¨æˆ·ç®¡ç†ç³»ç»Ÿçš„é›†æˆ

è¿™ç§æ¶æ„çš„ç‰¹ç‚¹æ˜¯ï¼š

1. **å¤šç§Ÿæˆ·æ”¯æŒ**ï¼šæ¯ä¸ªç”¨æˆ·å¯ä»¥åˆ›å»ºå’Œç®¡ç†è‡ªå·±çš„ä»£ç†
2. **èµ„æºéš”ç¦»**ï¼šå„ç”¨æˆ·çš„ä»£ç†äº’ç›¸éš”ç¦»
3. **é…é¢ç®¡ç†**ï¼šé™åˆ¶æ¯ä¸ªç”¨æˆ·å¯åˆ›å»ºçš„ä»£ç†æ•°é‡
4. **æ¨¡æ¿æ”¯æŒ**ï¼šå…è®¸ç”¨æˆ·ä»é¢„è®¾æ¨¡æ¿å¿«é€Ÿåˆ›å»ºä»£ç†
5. **å¼¹æ€§å¯æ‰©å±•**ï¼šä¸­é—´å±‚æ¶æ„å…è®¸å¤šä¸ªElizaå®ä¾‹æ ¹æ®è´Ÿè½½åŠ¨æ€æ‰©å±•

è¦å®Œæˆè¯¥ç³»ç»Ÿçš„éƒ¨ç½²ï¼Œä½ éœ€è¦ï¼š

1. è®¾ç½®PostgreSQLæ•°æ®åº“
2. é…ç½®å¹¶å¯åŠ¨ä¸­é—´å±‚æœåŠ¡
3. å°†å‰ç«¯Reactç»„ä»¶é›†æˆåˆ°ä½ çš„åº”ç”¨ä¸­
4. è®¾ç½®ElizaæœåŠ¡å®ä¾‹ï¼Œå¹¶ç¡®ä¿ä¸­é—´å±‚å¯ä»¥ä¸ä¹‹é€šä¿¡

è¿™ä¸ªæ¶æ„å…è®¸å¹³å°éšç€ç”¨æˆ·éœ€æ±‚çš„å¢é•¿è€Œçµæ´»æ‰©å±•ï¼ŒåŒæ—¶ä¿æŒå¼ºå¤§çš„èµ„æºéš”ç¦»æ€§èƒ½ã€‚

---

_**User**_

å½“è°ƒç”¨pnpm start --character...æ—¶å®é™…ä¸Šåˆ›å»ºagentçš„è¿‡ç¨‹æ˜¯ï¼Ÿ

---

_**Assistant**_

å½“ä½¿ç”¨`pnpm start --character...`å‘½ä»¤å¯åŠ¨Elizaå¹¶åˆ›å»ºä»£ç†æ—¶ï¼Œå®é™…å‘ç”Ÿçš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

## Elizaå¯åŠ¨å’Œä»£ç†åˆ›å»ºè¿‡ç¨‹

1. **å‘½ä»¤è§£æé˜¶æ®µ**
   - å½“æ‰§è¡Œ`pnpm start --character <character-config>`å‘½ä»¤æ—¶ï¼ŒElizaé¦–å…ˆè§£æå‘½ä»¤è¡Œå‚æ•°
   - `--character`å‚æ•°æŒ‡å®šäº†ä»£ç†çš„é…ç½®æ–‡ä»¶æˆ–é…ç½®å†…å®¹

2. **Elizaå®ä¾‹åˆå§‹åŒ–**
   - åŠ è½½æ ¸å¿ƒæœåŠ¡å’Œä¾èµ–é¡¹
   - é…ç½®ExpressæœåŠ¡å™¨
   - åˆå§‹åŒ–å„ç§ç®¡ç†å™¨ï¼ˆå¦‚AgentManagerï¼‰
   - è®¾ç½®APIè·¯ç”±å’Œç«¯ç‚¹

3. **è§’è‰²é…ç½®åŠ è½½**
   - è§£æ`--character`å‚æ•°æä¾›çš„é…ç½®
   - é…ç½®å¯ä»¥æ˜¯JSONæ–‡ä»¶è·¯å¾„æˆ–å†…è”JSONå­—ç¬¦ä¸²
   - å¦‚æœæ˜¯æ–‡ä»¶è·¯å¾„ï¼ŒElizaè¯»å–å¹¶è§£æè¯¥æ–‡ä»¶
   - éªŒè¯è§’è‰²é…ç½®æ˜¯å¦åŒ…å«å¿…è¦çš„å­—æ®µï¼ˆåç§°ã€ç³»ç»ŸæŒ‡ä»¤ç­‰ï¼‰

4. **ä»£ç†å®ä¾‹åˆ›å»º**
   - `AgentManager`è°ƒç”¨`createAgent`æ–¹æ³•
   - ç”Ÿæˆå”¯ä¸€çš„ä»£ç†IDï¼ˆé€šå¸¸æ˜¯UUIDï¼‰
   - åˆå§‹åŒ–ä»£ç†ä¸Šä¸‹æ–‡å’ŒçŠ¶æ€
   - è®¾ç½®ä»£ç†çš„æ¨¡å‹æä¾›è€…ï¼ˆå¦‚GPT-4ã€Claudeç­‰ï¼‰
   - é…ç½®ä»£ç†çš„ç³»ç»ŸæŒ‡ä»¤ã€è§’è‰²ä¿¡æ¯å’Œåˆå§‹å†…å­˜

5. **ä»£ç†æ³¨å†Œ**
   - æ–°åˆ›å»ºçš„ä»£ç†è¢«æ³¨å†Œåˆ°`AgentManager`ä¸­
   - æ›´æ–°ä»£ç†æ˜ å°„è¡¨ï¼Œå°†ä»£ç†IDä¸ä»£ç†å®ä¾‹å…³è”
   - è®¾ç½®ä»£ç†çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¤„ç†ç¨‹åº

6. **åˆå§‹åŒ–ä»£ç†è¿è¡Œæ—¶**
   - åˆå§‹åŒ–ä»£ç†ä¼šè¯å’Œå¯¹è¯å†å²
   - è®¾ç½®çŸ¥è¯†åº“ï¼ˆå¦‚æœé…ç½®ä¸­åŒ…å«ï¼‰
   - åˆå§‹åŒ–å·¥å…·å’Œèƒ½åŠ›ï¼ˆå¦‚æœé…ç½®ä¸­å®šä¹‰ï¼‰

7. **å¯åŠ¨ä»£ç†**
   - è°ƒç”¨ä»£ç†çš„`start`æ–¹æ³•
   - åˆå§‹åŒ–ä¸LLMæä¾›å•†çš„è¿æ¥
   - å‡†å¤‡ä»£ç†æ¥æ”¶æ¶ˆæ¯

8. **ç¡®è®¤å’ŒçŠ¶æ€æŠ¥å‘Š**
   - è®°å½•ä»£ç†åˆ›å»ºæˆåŠŸçš„æ—¥å¿—
   - è¿”å›ä»£ç†IDå’ŒçŠ¶æ€ä¿¡æ¯
   - APIæœåŠ¡å¼€å§‹ç›‘å¬è¯·æ±‚

## ä»£ç çº§è§†è§’

åœ¨Elizaçš„ä»£ç å®ç°ä¸­ï¼Œå½“ä½¿ç”¨`--character`å‚æ•°å¯åŠ¨æ—¶ï¼Œä»¥ä¸‹æ˜¯å¤§è‡´çš„æ‰§è¡Œæµç¨‹ï¼š

```javascript
// 1. å‘½ä»¤è¡Œå‚æ•°è§£æ
const parseArgs = () => {
  const args = process.argv.slice(2);
  const options = {};
  // è§£æ--characterå‚æ•°
  const characterIndex = args.indexOf('--character');
  if (characterIndex !== -1 && characterIndex + 1 < args.length) {
    options.character = args[characterIndex + 1];
  }
  return options;
};

// 2. å¯åŠ¨Eliza
const startEliza = async (options) => {
  // åˆå§‹åŒ–æ ¸å¿ƒæœåŠ¡
  const app = express();
  const agentManager = new AgentManager();
  
  // é…ç½®ä¸­é—´ä»¶å’Œè·¯ç”±
  setupMiddleware(app);
  setupRoutes(app, agentManager);
  
  // 3. å¦‚æœæœ‰characterå‚æ•°ï¼ŒåŠ è½½å¹¶åˆ›å»ºä»£ç†
  if (options.character) {
    try {
      // åŠ è½½è§’è‰²é…ç½®
      const characterConfig = loadCharacterConfig(options.character);
      
      // 4. åˆ›å»ºä»£ç†
      const agentId = await agentManager.createAgent(characterConfig);
      
      // 7. å¯åŠ¨ä»£ç†
      await agentManager.startAgent(agentId);
      
      console.log(`Agent created and started with ID: ${agentId}`);
    } catch (error) {
      console.error("Failed to create agent:", error);
    }
  }
  
  // å¯åŠ¨æœåŠ¡å™¨
  const server = app.listen(port, () => {
    console.log(`Eliza server running on port ${port}`);
  });
  
  return { app, server, agentManager };
};

// ä»£ç†åˆ›å»ºæ ¸å¿ƒé€»è¾‘
class AgentManager {
  async createAgent(config) {
    // ç”Ÿæˆå”¯ä¸€ID
    const agentId = uuidv4();
    
    // åˆå§‹åŒ–ä»£ç†é…ç½®
    const agentConfig = {
      id: agentId,
      name: config.name,
      systemInstructions: config.systemInstructions,
      modelProvider: config.modelProvider || 'gpt-4',
      // å…¶ä»–é…ç½®...
    };
    
    // åˆ›å»ºä»£ç†å®ä¾‹
    const agent = new Agent(agentConfig);
    
    // æ³¨å†Œä»£ç†
    this.agents[agentId] = agent;
    
    // åˆå§‹åŒ–ä»£ç†çŠ¶æ€
    await agent.initialize();
    
    return agentId;
  }
  
  async startAgent(agentId) {
    const agent = this.agents[agentId];
    if (!agent) {
      throw new Error(`Agent with ID ${agentId} not found`);
    }
    
    // å¯åŠ¨ä»£ç†
    await agent.start();
    return agent.getStatus();
  }
}
```

åœ¨å®é™…Elizaå®ç°ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹ä¼šæ›´åŠ å¤æ‚ï¼ŒåŒ…æ‹¬æ›´å¤šçš„é”™è¯¯å¤„ç†ã€é…ç½®éªŒè¯ã€ä»¥åŠä¸å„ç§æ¨¡å‹æä¾›å•†çš„é›†æˆç»†èŠ‚ã€‚ä½†ä¸Šè¿°ä»£ç æ¼”ç¤ºäº†åŸºæœ¬æµç¨‹ã€‚

## åœ¨å¤šç”¨æˆ·å¹³å°ç¯å¢ƒä¸­çš„æ„ä¹‰

åœ¨æˆ‘ä»¬å¼€å‘çš„å¤šç”¨æˆ·å¹³å°ä¸­ï¼Œè¿™ä¸ªæµç¨‹è¢«å°è£…åœ¨ä¸­é—´å±‚APIæœåŠ¡ä¸­ã€‚å½“ç”¨æˆ·é€šè¿‡å‰ç«¯ç•Œé¢åˆ›å»ºä»£ç†æ—¶ï¼š

1. ç”¨æˆ·å¡«å†™ä»£ç†é…ç½®å¹¶æäº¤
2. å‰ç«¯å‘é€åˆ›å»ºè¯·æ±‚åˆ°ä¸­é—´å±‚API
3. ä¸­é—´å±‚éªŒè¯ç”¨æˆ·æƒé™å’Œé…é¢
4. ä¸­é—´å±‚æ ¼å¼åŒ–ä»£ç†é…ç½®
5. ä¸­é—´å±‚è°ƒç”¨Eliza APIåˆ›å»ºä»£ç†ï¼ˆç±»ä¼¼äº`pnpm start --character`çš„è¿‡ç¨‹ï¼‰
6. ä¸­é—´å±‚è®°å½•ç”¨æˆ·-ä»£ç†å…³ç³»
7. è¿”å›ç»“æœç»™å‰ç«¯

è¿™ç§æ–¹å¼ä½¿å¾—å•ä¸€Elizaå®ä¾‹èƒ½å¤Ÿæ”¯æŒå¤šç”¨æˆ·ç¯å¢ƒï¼ŒåŒæ—¶ä¸­é—´å±‚æä¾›äº†å¿…è¦çš„éš”ç¦»å’Œèµ„æºç®¡ç†ã€‚

---

_**User**_

ä»å¤–éƒ¨ç½‘ç«™è°ƒç”¨apiå¯åŠ¨agentï¼Œå¸Œæœ›èƒ½å¤Ÿå°†db.sqliteè·Ÿuseridå…³è”, useridåœ¨ç”¨æˆ·å¯åŠ¨agentã€å‘é€ä¿¡æ¯æ—¶ä¼ é€’åˆ°elizaï¼Œä¾‹å¦‚userid-db.sqlite

---

_**Assistant**_

è¦å®ç°ä»å¤–éƒ¨ç½‘ç«™è°ƒç”¨APIå¯åŠ¨agentå¹¶å°†db.sqliteä¸useridå…³è”ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š

1. ä¿®æ”¹ä¸­é—´å±‚APIæœåŠ¡æ¥ä¼ é€’userid
2. è°ƒæ•´Elizaçš„æ•°æ®åº“é€‚é…å™¨é…ç½®
3. åˆ›å»ºAPIè°ƒç”¨å‡½æ•°

ä¸‹é¢æ˜¯å…·ä½“å®ç°ï¼š

## 1. ä¿®æ”¹ä¸­é—´å±‚APIæœåŠ¡

```javascript
// server/agentMiddlewareService.js (ä¿®æ”¹éƒ¨åˆ†)

// åœ¨å¯åŠ¨ä»£ç†çš„éƒ¨åˆ†æ·»åŠ ç”¨æˆ·IDå¤„ç†
app.post('/agents/:agentId/start', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™å¯åŠ¨æ­¤ä»£ç†' });
    }
    
    // è°ƒç”¨Eliza APIå¯åŠ¨ä»£ç†ï¼Œä¼ é€’userIdä½œä¸ºå‚æ•°
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}/start`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: userId,  // ä¼ é€’ç”¨æˆ·ID
        dbNamePrefix: `user-${userId}` // ä¸ºæ•°æ®åº“æ·»åŠ å‰ç¼€
      })
    });
    
    if (!elizaResponse.ok) {
      const errorData = await elizaResponse.json();
      return res.status(elizaResponse.status).json(errorData);
    }
    
    const result = await elizaResponse.json();
    res.json(result);
  } catch (error) {
    console.error("Error starting agent:", error);
    res.status(500).json({ error: error.message });
  }
});

// åŒæ ·åœ¨åˆ›å»ºä»£ç†æ—¶ä¼ é€’userId
app.post('/agents', authenticate, async (req, res) => {
  try {
    const userId = req.user.id;
    const agentData = req.body;
    
    // æ£€æŸ¥ç”¨æˆ·é…é¢
    const quota = await userAgentManager.getUserQuota(userId);
    if (quota.remaining <= 0) {
      return res.status(403).json({ 
        error: 'æ‚¨å·²è¾¾åˆ°ä»£ç†æ•°é‡ä¸Šé™', 
        quota 
      });
    }
    
    // è°ƒç”¨Eliza APIåˆ›å»ºä»£ç†ï¼Œä¼ é€’userId
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...agentData,
        metadata: {
          ...agentData.metadata,
          ownerId: userId
        },
        userId: userId, // ä¼ é€’ç”¨æˆ·ID
        dbNamePrefix: `user-${userId}` // ä¸ºæ•°æ®åº“æ·»åŠ å‰ç¼€
      })
    });
    
    // å…¶ä½™ä»£ç ä¸å˜...
  }
});

// åœ¨æ¶ˆæ¯å‘é€æ—¶ä¹Ÿä¼ é€’userId
app.post('/agents/:agentId/message', authenticate, upload.single('file'), async (req, res) => {
  try {
    const userId = req.user.id;
    const { agentId } = req.params;
    const { text } = req.body;
    
    // éªŒè¯ç”¨æˆ·æ˜¯å¦æœ‰æƒé™è®¿é—®æ­¤ä»£ç†
    const hasAccess = await userAgentManager.validateAgentAccess(userId, agentId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'æ‚¨æ²¡æœ‰æƒé™ä¸æ­¤ä»£ç†å¯¹è¯' });
    }
    
    // å‡†å¤‡å‘é€æ¶ˆæ¯ï¼ŒåŒ…å«userId
    const formData = new FormData();
    formData.append('text', text);
    formData.append('userId', userId); // ä¼ é€’ç”¨æˆ·ID
    
    // å¦‚æœæœ‰æ–‡ä»¶ï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
    if (req.file) {
      const fileBuffer = Buffer.from(await fs.readFile(req.file.path));
      formData.append('file', new Blob([fileBuffer]), req.file.originalname);
    }
    
    // è°ƒç”¨Eliza APIå‘é€æ¶ˆæ¯
    const elizaResponse = await fetch(`${ELIZA_BASE_URL}/agents/${agentId}/message`, {
      method: 'POST',
      body: formData
    });
    
    // å…¶ä½™ä»£ç ä¸å˜...
  }
});
```

## 2. ä¿®æ”¹Elizaä¾§çš„SQLé€‚é…å™¨ä»£ç 

éœ€è¦åœ¨Elizaé¡¹ç›®ä¸­ä¿®æ”¹SQLiteé€‚é…å™¨ï¼Œä½¿å…¶æ”¯æŒåŸºäºuserIdçš„æ•°æ®åº“æ–‡ä»¶ï¼š

```typescript
// packages/adapter-sqlite/src/index.ts ä¿®æ”¹éƒ¨åˆ†

const sqliteDatabaseAdapter: Adapter = {
    init: (runtime: IAgentRuntime) => {
        const dataDir = path.join(process.cwd(), "data");

        if (!fs.existsSync(dataDir)) {
            fs.mkdirSync(dataDir, { recursive: true });
        }

        // è·å–ç”¨æˆ·IDï¼Œå¦‚æœå­˜åœ¨åˆ™ç”¨äºæ•°æ®åº“æ–‡ä»¶å
        const userId = runtime.getSetting("USER_ID");
        const dbPrefix = userId ? `user-${userId}-` : "";
        
        // ä½¿ç”¨ç”¨æˆ·IDä½œä¸ºæ•°æ®åº“æ–‡ä»¶åå‰ç¼€
        const defaultDbName = userId ? `${dbPrefix}db.sqlite` : "db.sqlite";
        const filePath = runtime.getSetting("SQLITE_FILE") ?? path.resolve(dataDir, defaultDbName);
        
        elizaLogger.info(`Initializing SQLite database at ${filePath}...`);
        const db = new SqliteDatabaseAdapter(new Database(filePath));

        // å‰©ä½™ä»£ç ä¸å˜...
    },
};
```

## 3. ä¿®æ”¹Elizaçš„ä»£ç†ç®¡ç†æ¨¡å—ï¼Œç¡®ä¿å¯ä»¥æ¥æ”¶ç”¨æˆ·ID

```typescript
// åœ¨Elizaçš„ä»£ç†ç®¡ç†æ¨¡å—ä¸­æ·»åŠ ç”¨æˆ·IDå¤„ç†

// agent-manager.ts æˆ–ç±»ä¼¼æ–‡ä»¶
export class AgentManager {
    async createAgent(config: AgentConfig): Promise<string> {
        // ä»é…ç½®ä¸­è·å–ç”¨æˆ·ID
        const userId = config.userId;
        const dbNamePrefix = config.dbNamePrefix;
        
        // ç”Ÿæˆå”¯ä¸€ID
        const agentId = uuidv4();
        
        // åˆå§‹åŒ–ä»£ç†é…ç½®
        const agentConfig = {
            id: agentId,
            name: config.name,
            systemInstructions: config.systemInstructions,
            modelProvider: config.modelProvider || 'gpt-4',
            // ä¿å­˜ç”¨æˆ·IDåˆ°ä»£ç†é…ç½®
            userId: userId,
            // å…¶ä»–é…ç½®...
        };
        
        // å¦‚æœæä¾›äº†ç”¨æˆ·IDï¼Œåˆ™è®¾ç½®è¿è¡Œæ—¶è®¾ç½®
        if (userId) {
            this.runtime.setSetting("USER_ID", userId);
        }
        
        // å¦‚æœæä¾›äº†æ•°æ®åº“å‰ç¼€ï¼Œåˆ™è®¾ç½®æ•°æ®åº“æ–‡ä»¶è·¯å¾„
        if (dbNamePrefix) {
            const dataDir = path.join(process.cwd(), "data");
            const dbPath = path.resolve(dataDir, `${dbNamePrefix}-db.sqlite`);
            this.runtime.setSetting("SQLITE_FILE", dbPath);
        }
        
        // åˆ›å»ºä»£ç†å®ä¾‹
        const agent = new Agent(agentConfig, this.runtime);
        
        // æ³¨å†Œä»£ç†
        this.agents[agentId] = agent;
        
        // åˆå§‹åŒ–ä»£ç†çŠ¶æ€
        await agent.initialize();
        
        return agentId;
    }
    
    // åŒæ ·åœ¨å¤„ç†æ¶ˆæ¯æ—¶è€ƒè™‘ç”¨æˆ·ID
    async handleMessage(agentId: string, message: any): Promise<any> {
        const agent = this.getAgent(agentId);
        if (!agent) {
            throw new Error(`Agent with ID ${agentId} not found`);
        }
        
        // å¦‚æœæ¶ˆæ¯ä¸­åŒ…å«userIdï¼Œç¡®ä¿ä»£ç†ä½¿ç”¨æ­£ç¡®çš„æ•°æ®åº“
        if (message.userId) {
            this.runtime.setSetting("USER_ID", message.userId);
            
            // å¦‚æœéœ€è¦ï¼Œå¯ä»¥åœ¨è¿™é‡Œé‡æ–°è®¾ç½®æ•°æ®åº“è·¯å¾„
            const dataDir = path.join(process.cwd(), "data");
            const dbPath = path.resolve(dataDir, `user-${message.userId}-db.sqlite`);
            this.runtime.setSetting("SQLITE_FILE", dbPath);
        }
        
        // å¤„ç†æ¶ˆæ¯
        return await agent.processMessage(message);
    }
}
```

## 4. å‰ç«¯è°ƒç”¨å¯åŠ¨APIçš„ä»£ç ç¤ºä¾‹

```javascript
// src/services/agentService.js æ–°å¢å‡½æ•°

// ç›´æ¥è°ƒç”¨Eliza APIå¯åŠ¨ä»£ç†ï¼ˆè·³è¿‡ä¸­é—´å±‚ï¼Œç”¨äºé›†æˆåˆ°å…¶ä»–ç³»ç»Ÿï¼‰
const startAgentDirect = async (characterConfig, userId) => {
  try {
    // æ­¥éª¤1: åˆ›å»ºä»£ç†
    const createResponse = await fetch(`${ELIZA_API_URL}/agents`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...characterConfig,
        userId: userId,
        dbNamePrefix: `user-${userId}`
      })
    });
    
    if (!createResponse.ok) {
      throw new Error(`åˆ›å»ºä»£ç†å¤±è´¥: ${await createResponse.text()}`);
    }
    
    const { id: agentId } = await createResponse.json();
    
    // æ­¥éª¤2: å¯åŠ¨ä»£ç†
    const startResponse = await fetch(`${ELIZA_API_URL}/agents/${agentId}/start`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: userId,
        dbNamePrefix: `user-${userId}`
      })
    });
    
    if (!startResponse.ok) {
      throw new Error(`å¯åŠ¨ä»£ç†å¤±è´¥: ${await startResponse.text()}`);
    }
    
    return {
      agentId,
      status: 'running',
      message: 'ä»£ç†å·²æˆåŠŸå¯åŠ¨'
    };
  } catch (error) {
    console.error("Error in startAgentDirect:", error);
    throw error;
  }
};

// å‘ä»£ç†å‘é€æ¶ˆæ¯ï¼ˆç›´æ¥è°ƒç”¨ï¼Œç”¨äºé›†æˆï¼‰
const sendMessageDirect = async (agentId, message, userId, file = null) => {
  try {
    const formData = new FormData();
    formData.append('text', message);
    formData.append('userId', userId);
    
    if (file) {
      formData.append('file', file);
    }
    
    const response = await fetch(`${ELIZA_API_URL}/agents/${agentId}/message`, {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error(`å‘é€æ¶ˆæ¯å¤±è´¥: ${await response.text()}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error("Error in sendMessageDirect:", error);
    throw error;
  }
};

// å®Œæˆé›†æˆçš„ç¤ºä¾‹å‡½æ•°
const integrateWithExternalSystem = async (characterConfig, userId, initialMessage) => {
  try {
    // 1. å¯åŠ¨ä»£ç†
    const { agentId } = await startAgentDirect(characterConfig, userId);
    
    // 2. å‘é€åˆå§‹æ¶ˆæ¯
    if (initialMessage) {
      const response = await sendMessageDirect(agentId, initialMessage, userId);
      return {
        agentId,
        status: 'running',
        initialResponse: response
      };
    }
    
    return { agentId, status: 'running' };
  } catch (error) {
    console.error("Integration error:", error);
    throw error;
  }
};

// æ·»åŠ åˆ°å¯¼å‡º
export {
  startAgentDirect,
  sendMessageDirect,
  integrateWithExternalSystem
};
```

## 5. Reactç»„ä»¶ä¸­ä½¿ç”¨

```jsx
// src/components/integration/ExternalAgentLauncher.jsx
import React, { useState } from 'react';
import { useSelector } from 'react-redux';
import { 
  Button, 
  Input, 
  Select, 
  Card, 
  message, 
  Spin,
  Typography,
  Space
} from 'antd';
import { startAgentDirect, sendMessageDirect } from '../../services/agentService';

const { Title, Text } = Typography;
const { Option } = Select;
const { TextArea } = Input;

const ExternalAgentLauncher = () => {
  const { currentUser } = useSelector((state) => state.app);
  const [loading, setLoading] = useState(false);
  const [agentId, setAgentId] = useState(null);
  const [selectedTemplate, setSelectedTemplate] = useState('customer_support');
  const [userMessage, setUserMessage] = useState('');
  const [agentResponse, setAgentResponse] = useState('');
  
  // é¢„è®¾çš„è§’è‰²æ¨¡æ¿
  const characterTemplates = {
    customer_support: {
      name: "å®¢æœåŠ©æ‰‹",
      username: "support_assistant",
      bio: "ä¸“ä¸šçš„å®¢æˆ·æ”¯æŒä»£è¡¨",
      lore: "æˆ‘æ˜¯ä¸€åè®­ç»ƒæœ‰ç´ çš„å®¢æˆ·æ”¯æŒä¸“å®¶ï¼Œè‡´åŠ›äºè§£å†³æ‚¨çš„é—®é¢˜ã€‚",
      modelProvider: "gpt-4o",
      systemInstructions: "ä½ æ˜¯ä¸€åä¸“ä¸šçš„å®¢æˆ·æ”¯æŒä»£è¡¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯ç¤¼è²Œåœ°å›ç­”ç”¨æˆ·é—®é¢˜ï¼Œæä¾›å‡†ç¡®çš„ä¿¡æ¯ï¼Œå¹¶å°½å¯èƒ½è§£å†³ä»–ä»¬çš„é—®é¢˜ã€‚"
    },
    coach: {
      name: "èŒä¸šæ•™ç»ƒ",
      username: "career_coach",
      bio: "å¸®åŠ©æ‚¨è§„åˆ’èŒä¸šå‘å±•çš„æ•™ç»ƒ",
      lore: "ä½œä¸ºä¸€åèµ„æ·±èŒä¸šæ•™ç»ƒï¼Œæˆ‘å¯ä»¥å¸®åŠ©ä½ è§„åˆ’èŒä¸šè·¯å¾„ï¼Œæå‡èŒä¸šæŠ€èƒ½ã€‚",
      modelProvider: "claude-3-sonnet",
      systemInstructions: "ä½ æ˜¯ä¸€åèŒä¸šæ•™ç»ƒã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·å‘ç°è‡ªå·±çš„èŒä¸šå…´è¶£ï¼Œæä¾›èŒä¸šå»ºè®®ï¼Œå¹¶è¾…å¯¼ä»–ä»¬å®ç°èŒä¸šç›®æ ‡ã€‚"
    }
  };
  
  const handleLaunchAgent = async () => {
    if (!currentUser) {
      message.error('è¯·å…ˆç™»å½•');
      return;
    }
    
    setLoading(true);
    try {
      const template = characterTemplates[selectedTemplate];
      const { agentId: newAgentId } = await startAgentDirect(template, currentUser);
      
      setAgentId(newAgentId);
      message.success('ä»£ç†å¯åŠ¨æˆåŠŸ');
      
      // å‘é€åˆå§‹æ¬¢è¿æ¶ˆæ¯
      const initialResponse = await sendMessageDirect(newAgentId, 'ä½ å¥½', currentUser);
      setAgentResponse(initialResponse.response || initialResponse.text || 'ä»£ç†å·²å‡†å¤‡å¥½æ¥æ”¶æ¶ˆæ¯');
    } catch (error) {
      console.error('å¯åŠ¨ä»£ç†å¤±è´¥:', error);
      message.error('å¯åŠ¨ä»£ç†å¤±è´¥: ' + error.message);
    } finally {
      setLoading(false);
    }
  };
  
  const handleSendMessage = async () => {
    if (!agentId || !userMessage.trim()) return;
    
    setLoading(true);
    try {
      const response = await sendMessageDirect(agentId, userMessage, currentUser);
      setAgentResponse(response.response || response.text);
      setUserMessage('');
    } catch (error) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
      message.error('å‘é€æ¶ˆæ¯å¤±è´¥: ' + error.message);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="external-agent-launcher">
      <Card title="å¯åŠ¨å¤–éƒ¨ä»£ç†" bordered={false}>
        <Space direction="vertical" style={{ width: '100%' }}>
          {!agentId ? (
            <>
              <Select 
                value={selectedTemplate}
                onChange={setSelectedTemplate}
                style={{ width: '100%' }}
              >
                {Object.entries(characterTemplates).map(([key, template]) => (
                  <Option key={key} value={key}>{template.name}</Option>
                ))}
              </Select>
              
              <Button 
                type="primary" 
                onClick={handleLaunchAgent}
                loading={loading}
                block
              >
                å¯åŠ¨ä»£ç†
              </Button>
            </>
          ) : (
            <>
              <div className="chat-area">
                <Title level={4}>å¯¹è¯</Title>
                <Card className="response-card">
                  <Text>{agentResponse}</Text>
                </Card>
                
                <div className="message-input">
                  <TextArea
                    value={userMessage}
                    onChange={(e) => setUserMessage(e.target.value)}
                    placeholder="è¾“å…¥æ¶ˆæ¯..."
                    autoSize={{ minRows: 2, maxRows: 4 }}
                    disabled={loading}
                  />
                  <Button 
                    type="primary" 
                    onClick={handleSendMessage}
                    loading={loading}
                    disabled={!userMessage.trim()}
                    style={{ marginTop: 8 }}
                  >
                    å‘é€
                  </Button>
                </div>
              </div>
            </>
          )}
        </Space>
        
        {loading && <div className="loading-overlay"><Spin size="large" /></div>}
      </Card>
    </div>
  );
};

export default ExternalAgentLauncher;
```

## 6. å®Œæ•´æµç¨‹å›¾

1. ç”¨æˆ·ä»å¤–éƒ¨ç½‘ç«™å¯åŠ¨ä»£ç†
2. è¯·æ±‚ä¸­é™„å¸¦userId
3. Elizaæ¥æ”¶è¯·æ±‚ï¼Œåˆ›å»ºåŸºäºuserIdå‘½åçš„SQLiteæ•°æ®åº“
4. æ‰€æœ‰ä¸è¯¥ä»£ç†çš„äº¤äº’éƒ½ä½¿ç”¨è¯¥ç‰¹å®šæ•°æ®åº“
5. å¤šç”¨æˆ·å¹¶å‘ä½¿ç”¨æ—¶ï¼Œæ¯ä¸ªç”¨æˆ·éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„æ•°æ®åº“

è¿™ç§å®ç°æ–¹å¼ç¡®ä¿äº†æ¯ä¸ªç”¨æˆ·çš„ä»£ç†æ•°æ®éƒ½æ˜¯ç‹¬ç«‹å­˜å‚¨çš„ï¼Œæ»¡è¶³äº†å¤šç”¨æˆ·ç¯å¢ƒä¸‹çš„æ•°æ®éš”ç¦»éœ€æ±‚ï¼ŒåŒæ—¶ä¿æŒäº†Elizaçš„åŠŸèƒ½å®Œæ•´æ€§ã€‚

---

_**User**_

å¦‚ä½•åœ¨index.tsä¸­ç¡®ä¿å¯ä»¥æ¥æ”¶ç”¨æˆ·ID

---

_**Assistant**_

è¦åœ¨`index.ts`ä¸­ç¡®ä¿å¯ä»¥æ¥æ”¶ç”¨æˆ·IDå¹¶ä¸SQLiteæ•°æ®åº“å…³è”ï¼Œéœ€è¦ä¿®æ”¹ä»¥ä¸‹éƒ¨åˆ†ï¼š

1. åœ¨`AgentRuntime`åˆ›å»ºæ—¶æ¥æ”¶ç”¨æˆ·ID
2. ç¡®ä¿ç”¨æˆ·IDè¢«æ­£ç¡®è®¾ç½®åˆ°è¿è¡Œæ—¶è®¾ç½®ä¸­
3. ä¿®æ”¹ä»£ç†åˆ›å»ºæµç¨‹ä»¥æ”¯æŒç”¨æˆ·ID

ä¸‹é¢æ˜¯å…·ä½“çš„ä¿®æ”¹æ–¹æ¡ˆï¼š

```typescript
// agent/src/index.ts éœ€è¦ä¿®æ”¹çš„éƒ¨åˆ†

// ä¿®æ”¹åˆ›å»ºä»£ç†çš„å‡½æ•°ï¼Œæ·»åŠ userIdå‚æ•°
export async function createAgent(
    character: Character,
    token: string,
    userId?: string  // æ–°å¢å‚æ•°
): Promise<AgentRuntime> {
    elizaLogger.info(`Creating runtime for character ${character.name}`, {
        evaluators: ["streamGoalsEvaluator"],
        providers: ["streamGoalsProvider","streamGoalsCompletionProvider"]
    });
    
    const runtime = new AgentRuntime({
        token,
        modelProvider: character.modelProvider,
        evaluators: [streamGoalsEvaluator],
        character,
        plugins: [
            bootstrapPlugin,
        ]
            .flat()
            .filter(Boolean),
        providers: [streamGoalsProvider,streamGoalsCompletionProvider],
        managers: [],
        fetch: logFetch,
    });

    // å¦‚æœæä¾›äº†userIdï¼Œè®¾ç½®åˆ°è¿è¡Œæ—¶ç¯å¢ƒä¸­
    if (userId) {
        runtime.setSetting("USER_ID", userId);
        elizaLogger.info(`Setting USER_ID for character ${character.name}: ${userId}`);
    }

    elizaLogger.info("Runtime created with evaluators", { 
        evaluatorCount: runtime.evaluators?.length,
        evaluatorNames: runtime.evaluators?.map(e => e.name),
        evaluatorAlwaysRun: runtime.evalu

---



---

